<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IonChannel.jl Documentation · IonChannel.jl</title><meta name="title" content="IonChannel.jl Documentation · IonChannel.jl"/><meta property="og:title" content="IonChannel.jl Documentation · IonChannel.jl"/><meta property="twitter:title" content="IonChannel.jl Documentation · IonChannel.jl"/><meta name="description" content="Documentation for IonChannel.jl."/><meta property="og:description" content="Documentation for IonChannel.jl."/><meta property="twitter:description" content="Documentation for IonChannel.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>IonChannel.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>IonChannel.jl Documentation</a><ul class="internal"><li><a class="tocitem" href="#IonChannel"><span>IonChannel</span></a></li><li><a class="tocitem" href="#Read-Data"><span>Read Data</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Methods-of-idealization"><span>Methods of idealization</span></a></li><li><a class="tocitem" href="#Accuracy-of-methods"><span>Accuracy of methods</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Additional-functions"><span>Additional functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>IonChannel.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>IonChannel.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="IonChannel.jl-Documentation"><a class="docs-heading-anchor" href="#IonChannel.jl-Documentation">IonChannel.jl Documentation</a><a id="IonChannel.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#IonChannel.jl-Documentation" title="Permalink"></a></h1><h2 id="IonChannel"><a class="docs-heading-anchor" href="#IonChannel">IonChannel</a><a id="IonChannel-1"></a><a class="docs-heading-anchor-permalink" href="#IonChannel" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IonChannel" href="#IonChannel"><code>IonChannel</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">module IonChannel</code></pre><p>A Julia module for advanced idealization and analysis of ion channel single-molecule data.</p><p><strong>Overview</strong></p><p><a href="#IonChannel"><code>IonChannel</code></a> provides type-safe, highly modular tools for the idealization, segmentation, and analysis of ion channel current traces. It implements and integrates methods based on running-mean deviation, histogram-based segmentation, threshold optimization, MDL change-point detection, and deep-learning-based state detection, supporting workflows in quantitative biophysics and single-molecule electrophysiology.</p><p><strong>Main Features</strong></p><ul><li><p>Idealization Methods:</p><ul><li>Abstract parameter types (<a href="#Main.IonChannel.IdealizationMethod"><code>IdealizationMethod</code></a>) and result types (<a href="#Main.IonChannel.MethodOutput"><code>MethodOutput</code></a>) for extensible algorithms.</li><li>Implementations: deviation-from-mean (<a href="#Main.IonChannel.MeanDeviationMethod"><code>MeanDeviationMethod</code></a>), Mika method (<a href="#Main.IonChannel.MikaMethod"><code>MikaMethod</code></a>), Naive histogram thresholding (<a href="#Main.IonChannel.NaiveMethod"><code>NaiveMethod</code></a>), MDL segmentation (<a href="#Main.IonChannel.MDLMethod"><code>MDLMethod</code></a>), and DeepChannel (Python model via <code>PyCall</code>, <a href="#Main.IonChannel.DeepChannelMethod"><code>DeepChannelMethod</code></a>).</li></ul></li><li><p>Data Handling:</p><ul><li>Read paired raw traces and dwell times from files: <a href="#Main.IonChannel.read_data-Tuple{String, String}"><code>read_data</code></a>, or enumerate dataset folders with <a href="#Main.IonChannel.read_all_file_paths-Tuple{String}"><code>read_all_file_paths</code></a>.</li><li>Extract subsets, align dwell windows, and normalize signals: <a href="#Main.IonChannel.get_specified_datapoints"><code>get_specified_datapoints</code></a>, <a href="#Main.IonChannel.normalize_data-Tuple{Dict{String, Vector{Float32}}}"><code>normalize_data</code></a>, <a href="#Main.IonChannel.combine_time_with_data"><code>combine_time_with_data</code></a>.</li></ul></li><li><p>Histogram Analysis:</p><ul><li>Build histograms and probability histograms: <a href="#Main.IonChannel.histogram_calculator"><code>histogram_calculator</code></a>, <a href="#Main.IonChannel.calculate_probability_histogram-Tuple{StatsBase.Histogram}"><code>calculate_probability_histogram</code></a>.</li><li>Peak/trough and midpoint detection for bimodal signals: <a href="#Main.IonChannel.analyze_histogram_peaks-Tuple{StatsBase.Histogram}"><code>analyze_histogram_peaks</code></a> → <a href="#Main.IonChannel.HistPeakAnalysis"><code>HistPeakAnalysis</code></a>.</li></ul></li><li><p>Noise and Fit Evaluation:</p><ul><li>Residual modeling and statistics with <a href="#Main.IonChannel.Noise"><code>Noise</code></a> and <a href="#Main.IonChannel.noise_data-Tuple{Noise}"><code>noise_data</code></a>.</li><li>Dwell-time distribution comparison via <a href="#Main.IonChannel.calculate_mean_square_error"><code>calculate_mean_square_error</code></a> (returns MSE and histograms).</li><li>End-to-end benchmark across datasets with <a href="#Main.IonChannel.mean_error"><code>mean_error</code></a> (returns <a href="#Main.IonChannel.MeanError"><code>MeanError</code></a>).</li></ul></li><li><p>Visualization:</p><ul><li>Overlay exact vs. approximated breakpoints and thresholds: <a href="#Main.IonChannel.show_approx_on_plot-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}"><code>show_approx_on_plot</code></a>.</li><li>Stacked plots of raw vs. idealized sequences: <a href="#Main.IonChannel.plot_idealization_representation-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}"><code>plot_idealization_representation</code></a>.</li><li>Threshold and peaks on histogram (Mika): <a href="#Main.IonChannel.show_threshold_on_plot-Tuple{StatsBase.Histogram, HistPeakAnalysis, MikaMethodOutput}"><code>show_threshold_on_plot</code></a>.</li></ul></li></ul><p><strong>Typical Workflow</strong></p><ol><li><p>Reading Data: Use <a href="#Main.IonChannel.read_data-Tuple{String, String}"><code>read_data</code></a> or <a href="#Main.IonChannel.read_all_file_paths-Tuple{String}"><code>read_all_file_paths</code></a> to load trace data and associated dwell times.</p></li><li><p>Idealization: Choose an idealization method struct (e.g. <a href="#Main.IonChannel.MeanDeviationMethod"><code>MeanDeviationMethod</code></a>, <a href="#Main.IonChannel.MikaMethod"><code>MikaMethod</code></a>, <a href="#Main.IonChannel.NaiveMethod"><code>NaiveMethod</code></a>, <a href="#Main.IonChannel.MDLMethod"><code>MDLMethod</code></a>, <a href="#Main.IonChannel.DeepChannelMethod"><code>DeepChannelMethod</code></a>) and run the algorithm (e.g., <a href="#Main.IonChannel.calculate_method-Tuple{Vector{Float32}, IdealizationMethod, Float32}"><code>calculate_method</code></a>, <a href="#Main.IonChannel.mika_method-Tuple{Vector{Float32}, Float32, MikaMethod}"><code>mika_method</code></a>, <a href="#Main.IonChannel.naive_method-Tuple{Vector{Float32}, Float32, NaiveMethod}"><code>naive_method</code></a>, <a href="#Main.IonChannel.mdl_method-Tuple{Vector{Float32}, Float32, MDLMethod}"><code>mdl_method</code></a>, <a href="#Main.IonChannel.deep_channel_method-Tuple{Vector{Float32}, Float32, DeepChannelMethod}"><code>deep_channel_method</code></a>) to obtain a <code>&lt;: MethodOutput</code> with <code>breakpoints</code>, <code>dwell_times_approx</code>, and an <code>idealized_data</code> sequence.</p></li><li><p>Histogram and Threshold: Generate and analyze histograms with <a href="#Main.IonChannel.histogram_calculator"><code>histogram_calculator</code></a> and <a href="#Main.IonChannel.analyze_histogram_peaks-Tuple{StatsBase.Histogram}"><code>analyze_histogram_peaks</code></a>. Convert counts to probabilities via <a href="#Main.IonChannel.calculate_probability_histogram-Tuple{StatsBase.Histogram}"><code>calculate_probability_histogram</code></a>.</p></li><li><p>Visualization: Visualize results using <a href="#Main.IonChannel.show_approx_on_plot-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}"><code>show_approx_on_plot</code></a>, <a href="#Main.IonChannel.show_threshold_on_plot-Tuple{StatsBase.Histogram, HistPeakAnalysis, MikaMethodOutput}"><code>show_threshold_on_plot</code></a>, and <a href="#Main.IonChannel.plot_idealization_representation-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}"><code>plot_idealization_representation</code></a>.</p></li><li><p>Noise and Evaluation: Quantify residuals with <a href="#Main.IonChannel.noise_data-Tuple{Noise}"><code>noise_data</code></a> and evaluate dwell-time fit via <a href="#Main.IonChannel.calculate_mean_square_error"><code>calculate_mean_square_error</code></a>; assess full-run performance with <a href="#Main.IonChannel.mean_error"><code>mean_error</code></a>.</p></li></ol><p><strong>Extending the Module</strong></p><p>To add a new idealization method:</p><ol><li>Create a new parameter struct <code>&lt;: IdealizationMethod</code> (store parameters only).</li><li>Implement your algorithm <code>my_method(data::Vector{Float32}, t::Float32, m::MyMethod) -&gt; &lt;: MethodOutput</code>.</li><li>Link your method via <code>method_function(::MyMethod) = my_method</code> so it works with the generic <a href="#Main.IonChannel.calculate_method-Tuple{Vector{Float32}, IdealizationMethod, Float32}"><code>calculate_method</code></a>.</li></ol><p><strong>Key Types</strong></p><ul><li>Abstractions: <a href="#Main.IonChannel.IdealizationMethod"><code>IdealizationMethod</code></a>, <a href="#Main.IonChannel.MethodOutput"><code>MethodOutput</code></a></li><li>Methods and outputs: <a href="#Main.IonChannel.MeanDeviationMethod"><code>MeanDeviationMethod</code></a>, <a href="#Main.IonChannel.MeanDeviationMethodOutput"><code>MeanDeviationMethodOutput</code></a>; <a href="#Main.IonChannel.MikaMethod"><code>MikaMethod</code></a>, <a href="#Main.IonChannel.MikaMethodOutput"><code>MikaMethodOutput</code></a>; <a href="#Main.IonChannel.NaiveMethod"><code>NaiveMethod</code></a>, <a href="#Main.IonChannel.NaiveMethodOutput"><code>NaiveMethodOutput</code></a>; <a href="#Main.IonChannel.MDLMethod"><code>MDLMethod</code></a>, <a href="#Main.IonChannel.MDLMethodOutput"><code>MDLMethodOutput</code></a>; <a href="#Main.IonChannel.DeepChannelMethod"><code>DeepChannelMethod</code></a>, <a href="#Main.IonChannel.DeepChannelMethodOutput"><code>DeepChannelMethodOutput</code></a></li><li>Analysis helpers: <a href="#Main.IonChannel.HistPeakAnalysis"><code>HistPeakAnalysis</code></a>, <a href="#Main.IonChannel.ThresholdWidth"><code>ThresholdWidth</code></a>, <a href="#Main.IonChannel.Noise"><code>Noise</code></a>, <a href="#Main.IonChannel.Point"><code>Point</code></a>, <a href="#Main.IonChannel.Line"><code>Line</code></a></li><li>Evaluation aggregates: <a href="#Main.IonChannel.MeanError"><code>MeanError</code></a></li></ul><p><strong>Selected API (canonical names)</strong></p><ul><li><p>Data I/O and prep:</p><ul><li><code>read_data(data_file_path::String, dwell_times_path::String) -&gt; (x::Vector{Float32}, y::Vector{Float32})</code></li><li><code>read_all_file_paths(data_folder::String) -&gt; (what_first_path::String, data_file_paths::Vector{String}, dwell_times_file_paths::Vector{String})</code></li><li><code>get_specified_datapoints(x::Vector{Float32}, y::Vector{Float32}, t::Float32, data_size::UInt32=0) -&gt; Dict(&quot;x&quot;=&gt;..., &quot;dwell times&quot;=&gt;...)</code></li><li><code>normalize_data(data::Dict{String,Vector{Float32}}) -&gt; Vector{Float32}</code></li><li><code>combine_time_with_data(x::Vector{Float32}, t::Float32; batch_size::UInt8=1) -&gt; Vector{Tuple{Float32,Float32}}</code></li></ul></li><li><p>Histogram and peaks:</p><ul><li><code>histogram_calculator(x::Vector{Float32}, bins::UInt16=100) -&gt; StatsBase.Histogram</code></li><li><code>calculate_probability_histogram(h::Histogram) -&gt; Histogram</code></li><li><code>analyze_histogram_peaks(h::Histogram) -&gt; HistPeakAnalysis</code></li></ul></li><li><p>Idealization methods:</p><ul><li><code>deviation_from_mean_method(x::Vector{Float32}, t::Float32, m::MeanDeviationMethod) -&gt; MeanDeviationMethodOutput</code></li><li><code>mika_method(x::Vector{Float32}, t::Float32, m::MikaMethod) -&gt; MikaMethodOutput</code></li><li><code>naive_method(x::Vector{Float32}, t::Float32, m::NaiveMethod) -&gt; NaiveMethodOutput</code></li><li><code>mdl_method(x::Vector{Float32}, t::Float32, m::MDLMethod) -&gt; MDLMethodOutput</code></li><li><code>deep_channel_method(x::Vector{Float32}, t::Float32, m::DeepChannelMethod) -&gt; DeepChannelMethodOutput</code></li><li><code>method_function(::IdealizationMethod)</code> → returns the concrete callable for <a href="#Main.IonChannel.calculate_method-Tuple{Vector{Float32}, IdealizationMethod, Float32}"><code>calculate_method</code></a></li><li><code>calculate_method(x::Vector{Float32}, m::IdealizationMethod, t::Float32) -&gt; MethodOutput</code></li></ul></li><li><p>Evaluation and reconstruction:</p><ul><li><code>calculate_mean_square_error(data::Dict, dwell_times_approx::Vector{Float32}, dt_bins::UInt16=100) -&gt; (mse::Float32, hist_data::Histogram, hist_approx::Histogram)</code></li><li><code>accuracy_of_idealization(actual::Vector{UInt8}, approx::Vector{UInt8}) -&gt; Float32</code></li><li><code>mean_error(method::IdealizationMethod, t::Float32, data_size::UInt32, verbose::Bool=false) -&gt; MeanError</code></li><li><code>actual_idealize_data(data::Dict, what_first_dict::Dict{String,Int64}, file_name::AbstractString, t::Float32) -&gt; Vector{UInt8}</code></li><li><code>idealize_data(data::Vector{Float32}, dwell_times_approx::Vector{Float32}, hist::HistPeakAnalysis, t::Float32) -&gt; Vector{Float32}</code></li><li><code>create_idealizations(data_folder::String, t::Float32=1e-4f0) -&gt; Dict{String,Vector{Int8}}</code></li></ul></li><li><p>MDL internals (exposed helpers):</p><ul><li><code>_mdl(segment::Vector{Float32}, BP::Vector{UInt32}) -&gt; Float32</code></li><li><code>_test_breakpoint(segment::Vector{Float32}, candidate::Vector{UInt32}) -&gt; Bool</code></li><li><code>detect_single_breakpoint(data::Vector{Float32}, min_seg::UInt16=300) -&gt; Vector{UInt32}</code></li><li><code>detect_double_breakpoint(data::Vector{Float32}, min_seg::UInt16=300) -&gt; Vector{UInt32}</code></li><li><code>detect_breaks_mdl(segment::Vector{Float32}, method::AbstractString, min_seg::UInt16=300) -&gt; Vector{UInt32}</code></li><li><code>stepstat_mdl(data::Vector{Float32}, BP::Vector{UInt32}, threshold::Float32=0.8f0) -&gt; (filtered::Vector{UInt32}, stepvalues::Vector{Float32})</code></li></ul></li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using IonChannel

x, y = read_data(&quot;trace.txt&quot;, &quot;dwell.txt&quot;)

t = 1e-4f0
xnorm = normalize_data(Dict(&quot;x&quot; =&gt; x))
params = MikaMethod(UInt16(120))
result = calculate_method(xnorm, params, t)

show_approx_on_plot(Dict(&quot;x&quot;=&gt;x, &quot;dwell times&quot;=&gt;y), result, 0.5f0, 0.9f0, t)</code></pre><p><strong>Authors</strong></p><p>Created and maintained by <a href="https://github.com/p-j-o-t-e-r">Piotr Mika</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/IonChannel.jl#L1-L120">source</a></section></article><h2 id="Read-Data"><a class="docs-heading-anchor" href="#Read-Data">Read Data</a><a id="Read-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Read-Data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.combine_time_with_data" href="#Main.IonChannel.combine_time_with_data"><code>Main.IonChannel.combine_time_with_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combine_time_with_data(data::Vector{Float32}, Δt::Float32, batch_size::UInt8=1) -&gt; Vector{Tuple{Float32, Float32}}</code></pre><p>Create a time-stamped version of raw data, pairing each value with its time in the sampled sequence.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Float32}</code>  </li></ul><p>The signal or measurement data to be time-stamped.</p><ul><li><code>Δt::Float32</code>  </li></ul><p>The sampling interval (seconds) between consecutive data points.</p><ul><li><code>batch_size::UInt8</code> (optional, default = 1)  </li></ul><p>The step size for batch-wise processing; typically leave as 1 for full sequence.</p><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{Float32, Float32}}</code>  </li></ul><p>A vector of <code>(time, value)</code> pairs. The time values run from 0 to the end in steps of <code>Δt * batch_size</code>, each paired with the matching data value.</p><p><strong>Description</strong></p><p>Pairs each data point with its corresponding timestamp, supporting batch-wise access for processing algorithms that operate on downsampled or chunked data.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">data = [0.1, 0.2, 0.3, 0.4]
Δt = 0.01
pairs = combine_time_with_data(data, Δt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/read_data.jl#L221-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.get_specified_datapoints" href="#Main.IonChannel.get_specified_datapoints"><code>Main.IonChannel.get_specified_datapoints</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_specified_datapoints(x::Vector{Float32}, y::Vector{Float32}, Δt::Float32, data_size::UInt32=0) 
    -&gt; Dict{String, Vector{Float32}}</code></pre><p>Extract a segment of the <code>x</code> data vector and the corresponding <code>dwell times</code> segment  up to a specified number of data points or total recording time.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float32}</code>: Time series or measurement values.</li><li><code>y::Vector{Float32}</code>: Corresponding dwell times between events or state changes.</li><li><code>Δt::Float32</code>: Sampling interval in seconds for the <code>x</code> data.</li><li><code>data_size::UInt32</code> (optional, default=<code>0</code>):  </li></ul><p>Number of samples to include in the result.  </p><ul><li>If <code>0</code>, the entire dataset is used.</li><li>Otherwise, selects the first <code>data_size</code> samples of <code>x</code> and the dwell times covered by them.</li></ul><p><strong>Returns</strong></p><p><code>Dict{String, Vector{Float32}}</code>:</p><ul><li><code>&quot;x&quot;</code> → The truncated <code>x</code> vector containing the first <code>data_size</code> samples (or all samples if <code>data_size==0</code>).</li><li><code>&quot;dwell times&quot;</code> → A truncated version of <code>y</code> containing only those dwell time segments whose cumulative sum</li></ul><p>does not exceed <code>max_time = data_size * Δt</code>.</p><p><strong>Method</strong></p><ol><li>Determine the number of samples to include (<code>data_size</code>), using the full length of <code>x</code> if <code>data_size==0</code>.</li><li>Compute the <code>max_time</code> in seconds corresponding to the selected number of points.</li><li>Include only those dwell time segments from <code>y</code> whose cumulative sum is less than or equal to <code>max_time</code>.</li><li>Return both the truncated <code>x</code> and the matching truncated <code>y</code> in a dictionary.</li></ol><p><strong>Example</strong></p><pre><code class="nohighlight hljs">x, y = read_data(&quot;data.txt&quot;, &quot;dwell_times.txt&quot;)
data = get_specified_datapoints(x, y, Δt, 50)
println(data[&quot;x&quot;])
println(data[&quot;dwell times&quot;])</code></pre><p><strong>Notes</strong></p><ul><li>The dwell times are selected based on cumulative duration, <strong>not</strong> index count.</li><li>This function preserves the original order of the dwell times.</li><li>It assumes that <code>x</code> and <code>y</code> represent compatible datasets in terms of recording sequence.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/read_data.jl#L126-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.normalize_data-Tuple{Dict{String, Vector{Float32}}}" href="#Main.IonChannel.normalize_data-Tuple{Dict{String, Vector{Float32}}}"><code>Main.IonChannel.normalize_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize_data(data::Dict{String, Vector{Float32}}) -&gt; Vector{Float32}</code></pre><p>Normalize the <code>&quot;x&quot;</code> values in a data dictionary to have zero mean and unit variance using z-score normalization.</p><p><strong>Arguments</strong></p><ul><li><code>data::Dict{String, Vector{Float32}}</code>:  </li></ul><p>A dictionary containing at least the key <code>&quot;x&quot;</code> mapped to a vector of floating-point values (such as raw measurement data).   Other keys (e.g., <code>&quot;dwell times&quot;</code>) may be present but are ignored.</p><p><strong>Returns</strong></p><ul><li><code>Vector{Float32}</code>:  </li></ul><p>A new vector of the same length as <code>data[&quot;x&quot;]</code>, where each element has been normalized:</p><p>z<em>i = (x</em>i - μ) / σ</p><p>where μ is the mean of <code>x</code>, and σ is its standard deviation.</p><p><strong>Method</strong></p><ol><li>Fit a [<code>ZScore</code>] scaling model</li></ol><p>to the <code>&quot;x&quot;</code> values using <code>fit(ZScore, data[&quot;x&quot;])</code>.</p><ol><li>Apply the <code>normalize</code> function from <code>StatsBase</code> to transform the data into z-scores.</li><li>Return the transformed vector.</li></ol><p><strong>Example</strong></p><pre><code class="nohighlight hljs">x, y = read_data(&quot;data.txt&quot;, &quot;dwell_times.txt&quot;)
data = get_specified_datapoints(x, y, Δt, 50)
normalized_x = normalize_data(data)</code></pre><p><strong>Notes</strong></p><ul><li>Requires the <strong>StatsBase.jl</strong> and <strong>Normalization.jl</strong> package.</li><li>The <code>&quot;x&quot;</code> vector must not be empty and must contain finite real values.</li><li>This function does not modify the original dictionary; it returns a new normalized vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/read_data.jl#L177-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.read_all_file_paths-Tuple{String}" href="#Main.IonChannel.read_all_file_paths-Tuple{String}"><code>Main.IonChannel.read_all_file_paths</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>read<em>all</em>file<em>paths(data</em>folder::String) -&gt; Tuple{String, Vector{String}, Vector{String}}</p><p>Collect and return file paths for experimental data files and their corresponding dwell time files from a structured folder hierarchy.</p><p><strong>Arguments</strong></p><ul><li><code>data_folder::String</code>: The path (relative or absolute) to the main data folder.  </li></ul><p>The expected directory structure inside <code>data_folder</code> is:</p><p>data<em>folder/     sampling/         &lt;voltage1&gt;/             file1.txt             file2.txt             ...         &lt;voltage2&gt;/             ...     dwell</em>times/         &lt;voltage1&gt;/             file1<em>dwell</em>timesy.txt             ...         &lt;voltage2&gt;/             ...</p><p><strong>Returns</strong></p><p>A tuple:</p><ol><li><code>what_first_path::String</code> — Path to the first special file found at the top level of <code>data_folder</code></li></ol><p>(taken from the 3rd entry in its directory listing).</p><ol><li><code>data_file_paths::Vector{String}</code> — Full paths to all sampled data files across all voltages.</li><li><code>dwell_times_file_paths::Vector{String}</code> — Full paths to the corresponding dwell time files,</li></ol><p>in the same order as <code>data_file_paths</code>.</p><p><strong>File matching logic</strong></p><ul><li>Data files are taken from <code>/sampling/&lt;voltage&gt;/</code>, selecting every second file starting at index 2.</li><li>Dwell time files are taken from <code>/dwell_times/&lt;voltage&gt;/</code>, selecting every second file starting at index 1.</li><li>The dwell time file names are derived from the data file names by replacing the base name</li></ul><p>with <code>&lt;basename&gt;dwell_timesy</code> and preserving the original extension.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">what_first, data_paths, dwell_paths = read_all_file_paths(&quot;experiment_data&quot;)
println(&quot;First reference file: &quot;, what_first)
println(&quot;Number of data files: &quot;, length(data_paths))
println(&quot;Number of dwell time files: &quot;, length(dwell_paths))</code></pre><p><strong>Notes</strong></p><ul><li>Assumes a specific directory and file naming convention.</li><li>File order consistency is crucial for correctly matching data with dwell times.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/read_data.jl#L35-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.read_data-Tuple{String, String}" href="#Main.IonChannel.read_data-Tuple{String, String}"><code>Main.IonChannel.read_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>read<em>data(data</em>file<em>path::String, dwell</em>times_path::String) -&gt; Tuple{Vector{Float32}, Vector{Float32}}</p><p>Read numerical data from two text files and return them as vectors of <code>Float32</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data_file_path::String</code>: Path to a text file containing numerical values (one per line)</li></ul><p>representing the primary data set.</p><ul><li><code>dwell_times_path::String</code>: Path to a text file containing numerical values (one per line)</li></ul><p>corresponding to dwell times.</p><p><strong>Returns</strong></p><p>A tuple <code>(x, y)</code> where:</p><ul><li><code>x::Vector{Float32}</code>: Values read from the first file.</li><li><code>y::Vector{Float32}</code>: Values read from the second file.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">x, y = read_data(&quot;data.txt&quot;, &quot;dwell_times.txt&quot;)</code></pre><p>Both files must contain one floating-point number per line, with optional whitespace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/read_data.jl#L4-L26">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.DeepChannelMethod" href="#Main.IonChannel.DeepChannelMethod"><code>Main.IonChannel.DeepChannelMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DeepChannelMethod &lt;: IdealizationMethod</code></pre><p>Wrapper for a Python-based deep learning model used to idealize ion-channel time-series data into discrete states.</p><p>This type stores a reference to a Python model (e.g., a Keras/PyTorch model accessed via <code>PyCall.PyObject</code>) that supports per-sample classification (prediction) over the input trace after appropriate preprocessing.</p><p><strong>Fields</strong></p><ul><li><code>model::PyObject</code>: The underlying Python model object. It is expected to expose a prediction API compatible with the calling code (e.g., a <code>.predict</code> method that accepts a 4D tensor shaped like <code>(N, 1, 1, 1)</code> and returns class probabilities per sample).</li></ul><p><strong>Usage</strong></p><ul><li>Typically passed into <code>deep_channel_method(data, Δt, c_method)</code> to produce:<ul><li>per-sample predicted class labels,</li><li>transition breakpoints,</li><li>approximate dwell times.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Ensure PyCall is properly initialized and the Python environment includes all dependencies required by the model (e.g., TensorFlow/Keras or PyTorch).</li><li>Input preprocessing (e.g., scaling with <code>UnitRangeTransform</code> and reshaping to <code>(N,1,1,1)</code>) is handled by <a href="#Main.IonChannel.deep_channel_method-Tuple{Vector{Float32}, Float32, DeepChannelMethod}"><code>deep_channel_method</code></a>.</li><li>The model is expected to output a probability distribution over states for each sample; downstream code uses <code>argmax</code> to select the most likely class.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L413-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.DeepChannelMethodOutput" href="#Main.IonChannel.DeepChannelMethodOutput"><code>Main.IonChannel.DeepChannelMethodOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DeepChannelMethodOutput &lt;: MethodOutput</code></pre><p>Container for the outputs of the deep learning–based idealization (DeepChannel method).</p><p>Holds the approximate dwell times, transition times (breakpoints), and the full per-sample idealized state sequence.</p><p><strong>Fields</strong></p><ul><li><code>dwell_times_approx::Vector{Float32}</code>: Approximate durations spent in each detected state segment, typically computed from successive transition times.</li><li><code>breakpoints::Vector{Float32}</code>: Transition times (relative to the start of the trace) at which the state changes.</li><li><code>idealized_data::Vector{UInt8}</code>: Per-sample predicted states (e.g., <code>0</code>/<code>1</code>) produced by the model after preprocessing and decoding.</li></ul><p><strong>Notes</strong></p><ul><li>Units of <code>dwell_times_approx</code> and <code>breakpoints</code> depend on the sampling interval used upstream (e.g., <code>Δt</code> in seconds or milliseconds).</li><li><code>idealized_data</code> provides the full-resolution state assignment, while <code>dwell_times_approx</code> and <code>breakpoints</code> summarize state changes.</li><li>Designed to be returned by <a href="#Main.IonChannel.deep_channel_method-Tuple{Vector{Float32}, Float32, DeepChannelMethod}"><code>deep_channel_method</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L448-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.HistPeakAnalysis" href="#Main.IonChannel.HistPeakAnalysis"><code>Main.IonChannel.HistPeakAnalysis</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HistPeakAnalysis</code></pre><p>Structure holding the results of peak and trough analysis on a histogram.</p><p><strong>Fields</strong></p><ul><li><code>edges::Vector{Float32}</code>  </li></ul><p>The bin edges of the histogram.</p><ul><li><code>weights::Vector{Float32}</code>  </li></ul><p>The counts or weights for each histogram bin.</p><ul><li><code>pmax1::Float32</code>  </li></ul><p>The height (weight) of the first (primary) maximum peak.</p><ul><li><code>pmax1_index::Int</code>  </li></ul><p>The bin index of the first maximum peak.</p><ul><li><code>pmax2::Float32</code>  </li></ul><p>The height (weight) of the second maximum peak.</p><ul><li><code>pmax2_index::Int</code>  </li></ul><p>The bin index of the second maximum peak.</p><ul><li><code>midpoint::Int</code>  </li></ul><p>The index representing the midpoint between the two main peaks.</p><ul><li><code>pmin::Float32</code>  </li></ul><p>The height (weight) of the minimum (trough) between the two main peaks.</p><ul><li><code>pmin_index::Int</code>  </li></ul><p>The bin index of the minimum (trough) between the two main peaks.</p><p><strong>Description</strong></p><p><a href="#Main.IonChannel.HistPeakAnalysis"><code>HistPeakAnalysis</code></a> encapsulates detailed information about the histogram peaks and troughs necessary for further analysis such as threshold determination.</p><p>It is typically produced by the function <a href="#Main.IonChannel.analyze_histogram_peaks-Tuple{StatsBase.Histogram}"><code>analyze_histogram_peaks</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">hist_analysis = analyze_histogram_peaks(prob_hist)
println(&quot;Primary peak at bin &quot;, hist_analysis.pmax1_index, &quot; with weight &quot;, hist_analysis.pmax1)
println(&quot;Minimum between peaks at bin &quot;, hist_analysis.pmin_index)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L35-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.IdealizationMethod" href="#Main.IonChannel.IdealizationMethod"><code>Main.IonChannel.IdealizationMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IdealizationMethod</code></pre><p>Abstract supertype for all idealization method parameter types.</p><p>Each concrete subtype of <a href="#Main.IonChannel.IdealizationMethod"><code>IdealizationMethod</code></a> stores only the parameters specific to that method. The associated computation algorithm is defined separately and linked to the subtype via a <code>method(::YourMethodType)</code> function.</p><p><strong>Usage</strong></p><p>To implement a new method:</p><ol><li><p>Create a new struct subtype of <a href="#Main.IonChannel.IdealizationMethod"><code>IdealizationMethod</code></a> that stores parameters.</p></li><li><p>Write the algorithm function:</p><p>my_algorithm(data::Vector{Float32}, Δt::Float32, m::MyMethodType) -&gt; Vector{Float32}</p></li><li><p>Link it to the type with:</p><p>method(::MyMethodType) = my_algorithm</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.Line" href="#Main.IonChannel.Line"><code>Main.IonChannel.Line</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Line</code></pre><p>Represents a 2D line defined by the equation <code>y = a * x + b</code>.</p><p><strong>Fields</strong></p><ul><li><code>a::Float32</code> — The slope of the line.</li><li><code>b::Float32</code> — The y-intercept of the line.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">line = Line(2.0, 1.0) # y = 2x + 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L137-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.MDLMethod" href="#Main.IonChannel.MDLMethod"><code>Main.IonChannel.MDLMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MDLMethod &lt;: IdealizationMethod</code></pre><p>Configuration for an idealization approach based on the Minimum Description Length (MDL) principle.</p><p>The MDL method selects a piecewise-constant segmentation of the signal that minimizes the total description length (model complexity + data fit). It balances the number of segments (penalizing over-segmentation) against how well segments explain the data.</p><p><strong>Fields</strong></p><ul><li><code>min_seg::UInt16</code>: Minimum allowed segment length (in samples). Prevents overly short segments that are likely due to noise.</li><li><code>threshold::Float32</code>: Amplitude or penalty threshold used within the MDL search/criteria. Its interpretation depends on the specific implementation (e.g., penalty weight, merge/split decision threshold).</li><li><code>number_of_histogram_bins::UInt16</code>: Number of bins for any histogram-based auxiliary steps (e.g., estimating noise statistics or amplitude modes) used by the MDL routine.</li></ul><p><strong>Usage</strong></p><ul><li>Construct and pass to an MDL-based idealization function, e.g.: <code>mdl_method(data, Δt, method::MDLMethod) -&gt; MDLMethodOutput</code> (function and output type names may vary based on your implementation).</li></ul><p><strong>Notes</strong></p><ul><li>The MDL criterion typically trades off data fidelity and model complexity; tuning <code>min_seg</code> and <code>threshold</code> impacts the balance between false positives (spurious segments) and missed transitions.</li><li>Works well when the signal is piecewise constant with sparse change points and approximately stationary noise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L565-L594">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.MDLMethodOutput" href="#Main.IonChannel.MDLMethodOutput"><code>Main.IonChannel.MDLMethodOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MDLMethodOutput &lt;: MethodOutput</code></pre><p>Container for the results of an MDL-based idealization.</p><p>Holds the detected change-point times (breakpoints), the corresponding approximate dwell durations, and the full per-sample idealized state sequence.</p><p><strong>Fields</strong></p><ul><li><code>breakpoints::Vector{Float32}</code>: Times (relative to the start of the trace) at which the signal is estimated to change state according to the MDL segmentation.</li><li><code>dwell_times_approx::Vector{Float32}</code>: Approximate durations spent in each state segment, typically computed from successive <code>breakpoints</code> (the first dwell time usually equals the first breakpoint time).</li><li><code>idealized_data::Vector{UInt8}</code>: Per-sample state assignments (e.g., <code>0</code>/<code>1</code>) produced by the MDL idealization over the entire trace length.</li></ul><p><strong>Notes</strong></p><ul><li>Units of <code>breakpoints</code> and <code>dwell_times_approx</code> depend on the sampling interval used upstream (e.g., <code>Δt</code> in seconds or milliseconds).</li><li><code>idealized_data</code> provides the full-resolution labeling, while <code>breakpoints</code> and <code>dwell_times_approx</code> summarize the segmentation.</li><li>Designed to be returned by an MDL idealization routine (e.g., <a href="#Main.IonChannel.mdl_method-Tuple{Vector{Float32}, Float32, MDLMethod}"><code>mdl_method</code></a>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L602-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.MeanDeviationMethod" href="#Main.IonChannel.MeanDeviationMethod"><code>Main.IonChannel.MeanDeviationMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeanDeviationMethod &lt;: IdealizationMethod</code></pre><p>Parameters for the <em>deviation-from-running-mean</em> idealization method.</p><p><strong>Fields</strong></p><ul><li><code>δ::Float32</code> - Deviation offset subtracted from the absolute deviation before thresholding.</li><li><code>λ::Float32</code> - Threshold value above which a deviation from the mean indicates a state change.</li></ul><p><strong>Description</strong></p><p><a href="#Main.IonChannel.MeanDeviationMethod"><code>MeanDeviationMethod</code></a> stores only these two numeric parameters. The actual algorithm is implemented in <a href="#Main.IonChannel.deviation_from_mean_method-Tuple{Vector{Float32}, Float32, MeanDeviationMethod}"><code>deviation_from_mean_method</code></a> and linked via:</p><pre><code class="nohighlight hljs">method(::MeanDeviationMethod) = deviation_from_mean_method</code></pre><p><strong>Example</strong></p><pre><code class="language-m hljs">
println(method_function(m)) # shows the stored function
println(δ(m)) # 0.05
println(λ(m)) # 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L335-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.MeanDeviationMethodOutput" href="#Main.IonChannel.MeanDeviationMethodOutput"><code>Main.IonChannel.MeanDeviationMethodOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeanDeviationMethodOutput &lt;: MethodOutput</code></pre><p>Type describing the output of the mean deviation idealization method.</p><p><strong>Fields</strong></p><ul><li><p><code>breakpoints::Vector{Float32}</code>   The cumulative breakpoints (timepoints, in seconds) at which state changes occur in the idealized trace, as computed by the method.</p></li><li><p><code>dwell_times_approx::Vector{Float32}</code>   The sequence of estimated dwell times between state transitions (in seconds) produced by the algorithm.</p></li></ul><p><strong>Description</strong></p><p>This struct bundles the main outputs from the mean deviation idealization routine. It allows downstream analysis, comparison, or visualization of both raw and processed results.</p><p>Typically constructed and returned by <a href="#Main.IonChannel.deviation_from_mean_method-Tuple{Vector{Float32}, Float32, MeanDeviationMethod}"><code>deviation_from_mean_method</code></a> or generic idealization runners.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">result = deviation_from_mean_method(normalized_data, Δt, MeanDeviationMethod(δ, λ))
result.breakpoints # Vector of breakpoints (seconds)
result.dwell_times_approx # Vector of dwell times (seconds)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L378-L405">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.MeanError" href="#Main.IonChannel.MeanError"><code>Main.IonChannel.MeanError</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeanError</code></pre><p>Aggregate metrics for evaluating idealization or prediction performance across multiple segments, traces, or runs.</p><p><strong>Fields</strong></p><ul><li><code>mean_squared_error::Float32</code>: The overall mean of squared errors, typically averaged across all samples and/or batches.</li><li><code>mean_accuracy::Float32</code>: The overall accuracy aggregated across evaluations, commonly expressed as a fraction in <code>[0.0, 1.0]</code>.</li><li><code>mean_squared_errors::Vector{Float32}</code>: Per-segment or per-batch MSE values used to compute <code>mean_squared_error</code>.</li><li><code>accuracies::Vector{Float32}</code>: Per-segment or per-batch accuracy values used to compute <code>mean_accuracy</code>.</li></ul><p><strong>Notes</strong></p><ul><li>This struct is a convenient container when running repeated evaluations (e.g., cross-validation folds, multiple traces, or bootstrapped subsets).</li><li><code>mean_squared_error</code> is typically computed from <code>mean(mean_squared_errors)</code>, and <code>mean_accuracy</code> from <code>mean(accuracies)</code>, but storing all components keeps downstream analysis flexible (e.g., computing variance or confidence intervals).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L535-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.MethodOutput" href="#Main.IonChannel.MethodOutput"><code>Main.IonChannel.MethodOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MethodOutput</code></pre><p>Abstract supertype for all output types produced by idealization methods in <a href="#IonChannel"><code>IonChannel</code></a>.</p><p>All result types describing the outcome of an idealization algorithm—such as dwell times, breakpoints, noise metrics, and other analysis products—should subtype this.</p><p>This enables consistent downstream handling, generic dispatch, and unified documentation for results from different algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L24-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.MikaMethod" href="#Main.IonChannel.MikaMethod"><code>Main.IonChannel.MikaMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MikaMethod &lt;: IdealizationMethod</code></pre><p>Parameters and a method function for the Mika idealization method.</p><p><strong>Fields</strong></p><ul><li><code>number_of_histogram_bins::UInt16</code>  </li></ul><p>The number of bins used in histogram computations during idealization.</p><p><strong>Description</strong></p><p><a href="#Main.IonChannel.MikaMethod"><code>MikaMethod</code></a> stores parameters essential for controlling the thresholding and histogram binning in the Mika method. The associated algorithm is linked via <code>method_function(::MikaMethod)</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">m = MikaMethod(100)
result = calculate_method(data, m, Δt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L311-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.MikaMethodOutput" href="#Main.IonChannel.MikaMethodOutput"><code>Main.IonChannel.MikaMethodOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MikaMethodOutput &lt;: MethodOutput</code></pre><p>Structure holding the results of the Mika idealization method.</p><p><strong>Fields</strong></p><ul><li><code>breakpoints::Vector{Float32}</code>  </li></ul><p>Vector of cumulative breakpoint times (in seconds) indicating detected state changes.</p><ul><li><code>dwell_times_approx::Vector{Float32}</code>  </li></ul><p>Estimated dwell times (in seconds) between detected transitions.</p><ul><li><code>idealized_data::Vector{Float32}</code>  </li></ul><p>The reconstructed idealized signal corresponding to the original data.</p><ul><li><code>noise::Noise</code>  </li></ul><p>A <a href="#Main.IonChannel.Noise"><code>Noise</code></a> struct capturing residuals between the original and idealized data and associated statistics.</p><ul><li><code>threshold::ThresholdWidth</code>  </li></ul><p>The threshold and its bounds used for state transition detection.</p><ul><li><code>noise_mse::Float32</code>  </li></ul><p>The mean squared error between the noise and its fitted normal distribution.</p><p><strong>Description</strong></p><p><a href="#Main.IonChannel.MikaMethodOutput"><code>MikaMethodOutput</code></a> bundles all significant outputs of the Mika idealization procedure, enabling comprehensive downstream analysis and visualization.</p><p><strong>Accessor Functions</strong></p><p>Each field has a corresponding accessor function for convenient retrieval:</p><ul><li><code>breakpoints(optimized_data::MikaMethodOutput)</code>  </li><li><code>dwell_times_approx(optimized_data::MikaMethodOutput)</code>  </li><li><code>idealized_data(optimized_data::MikaMethodOutput)</code>  </li><li><code>noise(optimized_data::MikaMethodOutput)</code>  </li><li><code>threshold(optimized_data::MikaMethodOutput)</code>  </li><li><code>noise_mse(optimized_data::MikaMethodOutput)</code>  </li></ul><p>These allow accessing parts of the output without field syntax.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">result = mika_method(data, Δt, MikaMethod(120))

println(&quot;Threshold used: &quot;, threshold(result))
println(&quot;Number of breakpoints detected: &quot;, length(breakpoints(result)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L244-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.NaiveMethod" href="#Main.IonChannel.NaiveMethod"><code>Main.IonChannel.NaiveMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NaiveMethod &lt;: IdealizationMethod</code></pre><p>Configuration for a simple histogram-threshold-based idealization method.</p><p>This method estimates a decision threshold from the empirical distribution of signal amplitudes (via histogram analysis) and detects state transitions when the signal crosses that threshold.</p><p><strong>Fields</strong></p><ul><li><code>number_of_histogram_bins::UInt16</code>: Number of bins to use when building the amplitude histogram. A larger value can capture finer structure but may be noisier; typical ranges are 50-200 depending on data length and noise.</li></ul><p><strong>Usage</strong></p><ul><li>Pass an instance to <code>naive_method(data, Δt, method)</code> to produce:<ul><li>transition <code>breakpoints</code>,</li><li><code>dwell_times</code>,</li><li>per-sample binary <code>idealized_data</code> (0/1).</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>The chosen bin count influences the stability of the estimated threshold.</li><li>Works best for bimodal amplitude distributions with reasonably separated modes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L477-L500">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.NaiveMethodOutput" href="#Main.IonChannel.NaiveMethodOutput"><code>Main.IonChannel.NaiveMethodOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NaiveMethodOutput &lt;: MethodOutput</code></pre><p>Container for outputs produced by the histogram-threshold-based idealization pipeline (<a href="#Main.IonChannel.naive_method-Tuple{Vector{Float32}, Float32, NaiveMethod}"><code>naive_method</code></a>).</p><p><strong>Fields</strong></p><ul><li><code>dwell_times_approx::Vector{Float32}</code>: Approximate durations spent in each state segment, typically computed from differences between successive breakpoints (first element usually equals the first breakpoint time).</li><li><code>breakpoints::Vector{Float32}</code>: Transition times (relative to the start of the trace) at which the signal crosses the estimated threshold and the state flips.</li><li><code>idealized_data::Vector{UInt8}</code>: Per-sample binary state assignments (<code>0</code> or <code>1</code>) derived by tracking threshold crossings over the time series.</li></ul><p><strong>Notes</strong></p><ul><li>Units of <code>dwell_times_approx</code> and <code>breakpoints</code> are determined by the sampling interval used upstream (e.g., <code>Δt</code>).</li><li><code>idealized_data</code> provides the full-length state sequence, while <code>dwell_times_approx</code> and <code>breakpoints</code> summarize state changes.</li><li>Designed to be returned by <a href="#Main.IonChannel.naive_method-Tuple{Vector{Float32}, Float32, NaiveMethod}"><code>naive_method</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L505-L527">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.Noise" href="#Main.IonChannel.Noise"><code>Main.IonChannel.Noise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Noise</code></pre><p>Mutable structure holding noise characteristics computed as differences between raw data and idealized values.</p><p><strong>Fields</strong></p><ul><li><code>ξ::Vector{Float32}</code>  </li></ul><p>The vector of residuals (noise), computed as <code>data - idealized_values</code>.</p><ul><li><code>μ::Float32</code>  </li></ul><p>The mean of the noise vector.</p><ul><li><code>σ::Float32</code>  </li></ul><p>The standard deviation of the noise vector.</p><p><strong>Description</strong></p><p><a href="#Main.IonChannel.Noise"><code>Noise</code></a> encapsulates statistical information about deviation of the observed data from an idealized signal, useful for assessing fit quality and noise properties.</p><hr/><p><code>noise_data(noise::Noise) -&gt; Vector{Float32}</code>   Accessor function returning the raw noise vector <code>ξ</code>.</p><p><code>μ(noise::Noise) -&gt; Float32</code>   Accessor function returning the mean of the noise.</p><p><code>σ(noise::Noise) -&gt; Float32</code>   Accessor function returning the standard deviation of the noise.</p><hr/><p><code>noise(data::Vector{Float32}, idealized_values::Vector{Float32}) -&gt; Noise</code>   Computes and returns a <a href="#Main.IonChannel.Noise"><code>Noise</code></a> object representing the noise between raw data and idealized values.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Float32}</code>  </li></ul><p>The original data vector.</p><ul><li><code>idealized_values::Vector{Float32}</code>  </li></ul><p>The idealized or reconstructed data vector.</p><p><strong>Returns</strong></p><ul><li><a href="#Main.IonChannel.Noise"><code>Noise</code></a>  </li></ul><p>A <a href="#Main.IonChannel.Noise"><code>Noise</code></a> struct containing the residual vector and its statistical properties.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">data = [1.0, 2.1, 2.9, 4.1]
idealized = [1.0, 2.0, 3.0, 4.0]
n = noise(data, idealized)
println(&quot;Noise mean: &quot;, μ(n))
println(&quot;Noise std dev: &quot;, σ(n))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L156-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.Point" href="#Main.IonChannel.Point"><code>Main.IonChannel.Point</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Point</code></pre><p>A simple 2D point with <code>x</code> and <code>y</code> coordinates.</p><p><strong>Fields</strong></p><ul><li><code>x::Float32</code> — The horizontal coordinate.</li><li><code>y::Float32</code> — The vertical coordinate.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">p = Point(1.0, 2.0)
println(p.x) # 1.0
println(p.y) # 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L116-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.ThresholdWidth" href="#Main.IonChannel.ThresholdWidth"><code>Main.IonChannel.ThresholdWidth</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThresholdWidth</code></pre><p>Structure representing the threshold range for an idealization method.</p><p><strong>Fields</strong></p><ul><li><code>threshold_centre::Float32</code>  </li></ul><p>The central threshold value used for detecting state transitions.</p><ul><li><code>x₁::Float32</code>  </li></ul><p>The lower bound of the threshold band.</p><ul><li><code>x₂::Float32</code>  </li></ul><p>The upper bound of the threshold band.</p><p><strong>Description</strong></p><p><a href="#Main.IonChannel.ThresholdWidth"><code>ThresholdWidth</code></a> encapsulates the main threshold and its bounds within which the signal values are considered for state transition analysis.</p><p>It is typically computed during histogram-based threshold optimization and used for breakpoint detection.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">thr_width = ThresholdWidth(0.5, 0.3, 0.7)
println(&quot;Center threshold: &quot;, thr_width.threshold_centre)
println(&quot;Lower bound: &quot;, thr_width.x₁)
println(&quot;Upper bound: &quot;, thr_width.x₂)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L84-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.noise-Tuple{Vector{Float32}, Vector{Float32}}" href="#Main.IonChannel.noise-Tuple{Vector{Float32}, Vector{Float32}}"><code>Main.IonChannel.noise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Computes and returns a <a href="#Main.IonChannel.Noise"><code>Noise</code></a> object representing the noise between raw data and idealized values. See more in the <a href="#Main.IonChannel.Noise"><code>Noise</code></a> struct documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L233-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.noise_data-Tuple{Noise}" href="#Main.IonChannel.noise_data-Tuple{Noise}"><code>Main.IonChannel.noise_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">noise_data(noise::Noise) -&gt; Vector{Float32}</code></pre><p>Accessor function returning the raw noise vector <code>ξ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L213-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.δ-Tuple{MeanDeviationMethod}" href="#Main.IonChannel.δ-Tuple{MeanDeviationMethod}"><code>Main.IonChannel.δ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">δ(m::MeanDeviationMethod) -&gt; Float32</code></pre><p>Return the <code>δ</code> (delta) parameter from the given <a href="#Main.IonChannel.MeanDeviationMethod"><code>MeanDeviationMethod</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L364-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.λ-Tuple{MeanDeviationMethod}" href="#Main.IonChannel.λ-Tuple{MeanDeviationMethod}"><code>Main.IonChannel.λ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">λ(m::MeanDeviationMethod) -&gt; Float32</code></pre><p>Return the <code>λ</code> (lambda) parameter from the given <a href="#Main.IonChannel.MeanDeviationMethod"><code>MeanDeviationMethod</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L371-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.μ-Tuple{Noise}" href="#Main.IonChannel.μ-Tuple{Noise}"><code>Main.IonChannel.μ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">μ(noise::Noise) -&gt; Float32</code></pre><p>Accessor function returning the mean of the noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.σ-Tuple{Noise}" href="#Main.IonChannel.σ-Tuple{Noise}"><code>Main.IonChannel.σ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">σ(noise::Noise) -&gt; Float32</code></pre><p>Accessor function returning the standard deviation of the noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/types.jl#L226-L230">source</a></section></article><h2 id="Methods-of-idealization"><a class="docs-heading-anchor" href="#Methods-of-idealization">Methods of idealization</a><a id="Methods-of-idealization-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-of-idealization" title="Permalink"></a></h2><h3 id="Naive-Method"><a class="docs-heading-anchor" href="#Naive-Method">Naive Method</a><a id="Naive-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-Method" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.method_function-Tuple{NaiveMethod}" href="#Main.IonChannel.method_function-Tuple{NaiveMethod}"><code>Main.IonChannel.method_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">method_function(::NaiveMethod) -&gt; Function</code></pre><p>Return the algorithm function associated with a <a href="#Main.IonChannel.NaiveMethod"><code>NaiveMethod</code></a>.</p><p>This allows code like <code>calculate_method(data, m, Δt)</code> to work for any <a href="#Main.IonChannel.IdealizationMethod"><code>IdealizationMethod</code></a> subtype without changing the executor logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/naive_method.jl#L114-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.naive_method-Tuple{Vector{Float32}, Float32, NaiveMethod}" href="#Main.IonChannel.naive_method-Tuple{Vector{Float32}, Float32, NaiveMethod}"><code>Main.IonChannel.naive_method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">naive_method(
    data::Vector{Float32},
    Δt::Float32,
    method::NaiveMethod
) :: NaiveMethodOutput</code></pre><p>Perform a simple threshold-based idealization of a time-series by detecting crossings between two histogram-derived peaks.</p><p>This method:</p><ol><li>builds a histogram of the signal,</li><li>converts it to a probability histogram,</li><li>analyzes peak structure to estimate a threshold between two modes,</li><li>detects state transitions (0 ↔ 1) when the signal crosses that threshold,</li><li>returns breakpoints, dwell times, and the binary idealized state sequence.</li></ol><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Float32}</code>: The raw time-series trace to be idealized.</li><li><code>Δt::Float32</code>: Sampling interval used to assign times to samples and compute dwell durations.</li><li><code>method::NaiveMethod</code>: Configuration object that must provide <code>number_of_histogram_bins</code> and supports the auxiliary functions used here (see Notes).</li></ul><p><strong>Returns</strong></p><ul><li><a href="#Main.IonChannel.NaiveMethodOutput"><code>NaiveMethodOutput</code></a>: A struct with fields:<ul><li><code>breakpoints::Vector{Float32}</code>: Times at which state transitions occur.</li><li><code>dwell_times::Vector{Float32}</code>: Durations between successive breakpoints (first dwell time is <code>breakpoints[1]</code>).</li><li><code>idealized_data::Vector{Int}</code>: Binary sequence of states per sample (<code>0</code> or <code>1</code>).</li></ul></li></ul><p><strong>Method</strong></p><ol><li>Compute histogram and probability histogram:<ul><li><code>histogram_of_data = histogram_calculator(data, method.number_of_histogram_bins)</code></li><li><code>prob_hist = calculate_probability_histogram(histogram_of_data)</code></li></ul></li><li>Estimate threshold from histogram peak analysis:<ul><li><code>hist_analysis = analyze_histogram_peaks(prob_hist)</code></li><li><code>threshold = hist_analysis.edges[hist_analysis.pmin_index]</code></li></ul></li><li>Combine times with data:<ul><li><code>data_with_times = combine_time_with_data(data, Δt)</code> (expected shape <code>Nx2</code>, columns: time, value)</li></ul></li><li>Initialize state from first sample relative to <code>threshold</code>.</li><li>Iterate through samples:<ul><li>Detect upward crossings (0→1) when previous &lt; threshold and current &gt; threshold.</li><li>Detect downward crossings (1→0) when previous &gt; threshold and current &lt; threshold.</li><li>Record transition times in <code>breakpoints</code> and append <code>current_state</code> to <code>idealized_data</code>.</li></ul></li><li>Compute dwell times:<ul><li><code>dwell_times = append!([breakpoints[1]], diff(breakpoints))</code></li></ul></li><li>Return <code>NaiveMethodOutput(breakpoints, dwell_times, idealized_data)</code>.</li></ol><p><strong>Notes</strong></p><ul><li>The following helper functions are expected to be available in scope:<ul><li><code>histogram_calculator(data::AbstractVector, nbins::Integer)</code></li><li><code>calculate_probability_histogram(histogram)</code></li><li><code>analyze_histogram_peaks(prob_hist)</code> returning at least <code>edges</code> and <code>pmin_index</code></li><li><code>combine_time_with_data(data, Δt)</code> returning a 2-column array <code>[time value]</code></li></ul></li><li>State labeling convention: below threshold → <code>0</code>, above threshold → <code>1</code>.</li><li><code>idealized_data</code> is constructed sample-by-sample; breakpoints are continuous-time instants.</li><li>The code assumes at least one crossing; if <code>breakpoints</code> is empty, computing <code>dwell_times</code> as written will error. Consider guarding this case in production.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">trace = rand(Float32, 10_000)
Δt = 1f-4
method = NaiveMethod(number_of_histogram_bins = 100)

result = naive_method(trace, Δt, method)

println(&quot;Breakpoints: &quot;, result.breakpoints)
println(&quot;Dwell times: &quot;, result.dwell_times)
println(&quot;First 20 states: &quot;, result.idealized_data[1:20])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/naive_method.jl#L1-L72">source</a></section></article><h3 id="Mean-Deviation-Method"><a class="docs-heading-anchor" href="#Mean-Deviation-Method">Mean Deviation Method</a><a id="Mean-Deviation-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-Deviation-Method" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.deviation_from_mean_method-Tuple{Vector{Float32}, Float32, MeanDeviationMethod}" href="#Main.IonChannel.deviation_from_mean_method-Tuple{Vector{Float32}, Float32, MeanDeviationMethod}"><code>Main.IonChannel.deviation_from_mean_method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deviation_from_mean_method(data::Vector{Float32}, Δt::Float32, c_method::MeanDeviationMethod) -&gt; Vector{Float32}</code></pre><p>Estimate dwell times by detecting deviations from a running mean.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Float32}</code> - The (usually normalized) signal to analyse.</li><li><code>Δt::Float32</code> - Sampling interval in seconds.</li><li><code>m::MeanDeviationMethod</code> - Parameters container; provides <code>m.δ</code> and <code>m.λ</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float32}</code> - Estimated dwell times in seconds.</li></ul><p><strong>Algorithm</strong></p><ol><li>Start with the first value as the mean.</li><li>For each new sample:</li></ol><ul><li>If <em>not</em> in &quot;different state&quot; mode, update the running mean.</li><li>Compute <code>abs(sample - mean) - m.δ</code>.</li><li>If above <code>m.λ</code>, trigger a state change and record dwell segment length.</li><li>Otherwise, continue counting the current dwell segment.</li></ul><ol><li>Return the list of dwell segment durations.</li></ol><p><strong>Example</strong></p><pre><code class="nohighlight hljs">signal = [0.0, 0.1, 0.2, 1.5, 1.6, 1.7, 0.2, 0.1, 0.05]

m = MeanDeviationMethod(0.05, 0.5)

Δt = 0.1 # 100 ms sampling interval

dwell_times_est = deviation_from_mean_method(signal, Δt, m)

println(dwell_times_est) # e.g., [0.3, 0.3, 0.3]</code></pre><p><strong>Notes</strong></p><ul><li>Produces only complete dwell segments; last partial segment is not appended.</li><li>Works best on normalized or detrended signals to remove baseline drift.</li><li><code>δ(c_method)</code> suppresses detection of very small fluctuations.</li><li><code>λ(c_method)</code> controls the sensitivity: smaller values detect more frequent changes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mean_deviation_method.jl#L12-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.method_function-Tuple{MeanDeviationMethod}" href="#Main.IonChannel.method_function-Tuple{MeanDeviationMethod}"><code>Main.IonChannel.method_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">method_function(::MeanDeviationMethod) -&gt; Function</code></pre><p>Return the algorithm function associated with a <a href="#Main.IonChannel.MeanDeviationMethod"><code>MeanDeviationMethod</code></a>.</p><p>This allows code like <code>calculate_method(data, m, Δt)</code> to work for any <a href="#Main.IonChannel.IdealizationMethod"><code>IdealizationMethod</code></a> subtype without changing the executor logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mean_deviation_method.jl#L2-L9">source</a></section></article><h3 id="Mika-Method"><a class="docs-heading-anchor" href="#Mika-Method">Mika Method</a><a id="Mika-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Mika-Method" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.calculate_approximation-Tuple{Vector{Tuple{Float32, Float32}}, ThresholdWidth}" href="#Main.IonChannel.calculate_approximation-Tuple{Vector{Tuple{Float32, Float32}}, ThresholdWidth}"><code>Main.IonChannel.calculate_approximation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_approximation(data_with_times::Vector{Tuple{Float32, Float32}}, threshold::ThresholdWidth) 
    -&gt; Tuple{Vector{Float32}, Vector{Float32}}</code></pre><p>Estimate breakpoints and dwell times in a time-stamped signal using a threshold band.</p><p><strong>Arguments</strong></p><ul><li><code>data_with_times::Vector{Tuple{Float32, Float32}}</code>  </li></ul><p>Vector of <code>(time, value)</code> pairs for the signal, e.g. output from <a href="#Main.IonChannel.combine_time_with_data"><code>combine_time_with_data</code></a>.</p><ul><li><code>threshold::ThresholdWidth</code>  </li></ul><p>Threshold band object defining the central threshold and its lower/upper bounds.</p><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Float32}, Vector{Float32}}</code>  </li></ul><p>A tuple containing:     1. <code>breakpoints::Vector{Float32}</code> — estimated transition times (seconds)     2. <code>dwell_times::Vector{Float32}</code> — computed dwell times (seconds) between transitions</p><p><strong>Description</strong></p><p>This algorithm tracks signal transitions using a threshold band, finding:</p><ul><li>Intervals where the signal is within the threshold band</li><li>Median times of such intervals are treated as breakpoints</li><li>Dwell times are computed as time differences between breakpoints</li></ul><p>The method handles both edge and intermediate threshold crossing logic, smoothing via medians if needed, and properly catching transitions even when noise fluctuates.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">pairs = combine_time_with_data(data, Δt)
thr_band = get_threshold_width(hist_analysis, ϵ)
breaks, dwell_times = calculate_approximation(pairs, thr_band)
println(&quot;First dwell time: &quot;, dwell_times)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mika_method.jl#L138-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.get_threshold_width-Tuple{HistPeakAnalysis, Float32}" href="#Main.IonChannel.get_threshold_width-Tuple{HistPeakAnalysis, Float32}"><code>Main.IonChannel.get_threshold_width</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_threshold_width(hist_analysis::HistPeakAnalysis, ϵ::Float32) -&gt; ThresholdWidth</code></pre><p>Compute the threshold band used for state discrimination in idealization, based on histogram analysis and a weighting parameter.</p><p><strong>Arguments</strong></p><ul><li><code>hist_analysis::HistPeakAnalysis</code>  </li></ul><p>Result of peak analysis on a histogram, containing peak and minimum bin indices and values.</p><ul><li><code>ϵ::Float32</code>  </li></ul><p>Weighting parameter that adjusts the positions of threshold bounds between minimum and peak values.</p><p><strong>Returns</strong></p><ul><li><a href="#Main.IonChannel.ThresholdWidth"><code>ThresholdWidth</code></a>  </li></ul><p>Structure detailing the central threshold and its lower (<code>x₁</code>) and upper (<code>x₂</code>) bounds.</p><p><strong>Description</strong></p><p>Calculates a threshold band (region between two values) by linearly interpolating between the minimum and each peak, weighted by ϵ. This band is used to classify points in the signal for idealization methods.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">thr_width = get_threshold_width(hist_analysis, 0.1)
println(&quot;Threshold center: &quot;, thr_width.threshold_centre)
println(&quot;Lower bound: &quot;, thr_width.x₁)
println(&quot;Upper bound: &quot;, thr_width.x₂)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mika_method.jl#L83-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.line-Tuple{Point, Point}" href="#Main.IonChannel.line-Tuple{Point, Point}"><code>Main.IonChannel.line</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">line(point1::Point, point2::Point) -&gt; Line</code></pre><p>Construct a <a href="#Main.IonChannel.Line"><code>Line</code></a> (y = a*x + b) passing through two points.</p><p><strong>Arguments</strong></p><ul><li><code>point1::Point</code>  </li></ul><p>The first point <code>(x₁, y₁)</code> through which the line will pass.</p><ul><li><code>point2::Point</code>  </li></ul><p>The second point <code>(x₂, y₂)</code> through which the line will pass.</p><p><strong>Returns</strong></p><ul><li><a href="#Main.IonChannel.Line"><code>Line</code></a>  </li></ul><p>A line in slope-intercept form (<code>y = a*x + b</code>), where <code>a</code> is the slope and <code>b</code> is the intercept.</p><p><strong>Description</strong></p><p>Computes the slope (<code>a</code>) and y-intercept (<code>b</code>) for the line passing through two supplied points.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">p1 = Point(1.0, 2.0)
p2 = Point(3.0, 5.0)
l = line(p1, p2)
println(&quot;y = $(l.a)x + $(l.b)&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mika_method.jl#L51-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.method_function-Tuple{MikaMethod}" href="#Main.IonChannel.method_function-Tuple{MikaMethod}"><code>Main.IonChannel.method_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">method_function(::MikaMethod) -&gt; Function</code></pre><p>Return the algorithm function associated with a <a href="#Main.IonChannel.MikaMethod"><code>MikaMethod</code></a>.</p><p>This allows code like <code>calculate_method(data, m, Δt)</code> to work for any <a href="#Main.IonChannel.IdealizationMethod"><code>IdealizationMethod</code></a> subtype without changing the executor logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mika_method.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.mika_method-Tuple{Vector{Float32}, Float32, MikaMethod}" href="#Main.IonChannel.mika_method-Tuple{Vector{Float32}, Float32, MikaMethod}"><code>Main.IonChannel.mika_method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mika_method(data::Vector{Float32}, Δt::Float32, method::MikaMethod) -&gt; MikaMethodOutput</code></pre><p>Apply the Mika idealization algorithm to a signal, using histogram-based thresholding and noise optimization.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Float32}</code>  </li></ul><p>The original raw signal to be idealized.</p><ul><li><code>Δt::Float32</code>  </li></ul><p>Sampling interval in seconds.</p><ul><li><code>method::MikaMethod</code>  </li></ul><p>Parameters for the Mika method, including histogram bin count.</p><p><strong>Returns</strong></p><ul><li><a href="#Main.IonChannel.MikaMethodOutput"><code>MikaMethodOutput</code></a>  </li></ul><p>Comprehensive structure containing breakpoints, dwell times, idealized signal, noise statistics, and optimized thresholds.</p><p><strong>Description</strong></p><p>This method:</p><ol><li>Computes a signal histogram and probability histogram.</li><li>Analyzes histogram peaks to set up threshold bands.</li><li>Estimates initial breakpoints and dwell times via the threshold region.</li><li>Constructs the idealized signal alternating between two peak levels.</li><li>Assesses noise and fits a normal distribution for MSE optimization.</li><li>Iteratively adjusts (optimizes) the threshold to minimize noise MSE.</li><li>Returns all outcomes in a <a href="#Main.IonChannel.MikaMethodOutput"><code>MikaMethodOutput</code></a> struct for further analysis or plotting.</li></ol><p><strong>Example</strong></p><pre><code class="nohighlight hljs">params = MikaMethod(ϵ=0.05, number_of_histogram_bins=80)
result = mika_method(data, Δt, params)
println(&quot;Breakpoints: &quot;, breakpoints(result))
println(&quot;Noise MSE: &quot;, noise_mse(result))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mika_method.jl#L284-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.noise_test-Tuple{Noise}" href="#Main.IonChannel.noise_test-Tuple{Noise}"><code>Main.IonChannel.noise_test</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">noise_test(noise::Noise) :: Float32</code></pre><p>Evaluate the normality of noise samples by batching the data and averaging Shapiro-Wilk test p-values.</p><p>This function splits the noise sequence into fixed-size batches, runs a <code>ShapiroWilkTest</code> on each batch, and returns the mean p-value as a summary normality score.</p><p><strong>Arguments</strong></p><ul><li><code>noise::Noise</code>: A noise container with fields:<ul><li><code>ξ::Vector{Float32}</code>: The raw noise samples.</li><li><code>μ::Float32</code>: Mean of the noise (metadata; not used in this function).</li><li><code>σ::Float32</code>: Standard deviation of the noise (metadata; not used here).</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: The average p-value from Shapiro-Wilk tests across all complete batches. Higher values suggest better agreement with normality.</li></ul><p><strong>Details</strong></p><ul><li>Uses a fixed <code>batch_size = 50</code>.</li><li>Only complete batches are tested: <code>num_batches = div(length(noise_data(noise)), batch_size)</code>. Any remainder samples are ignored.</li><li>For each batch, computes <code>ShapiroWilkTest(batch)</code> and stores <code>pvalue(test)</code>.</li><li>Returns <code>mean(pvals)</code>.</li></ul><p><strong>Notes</strong></p><ul><li>Requires <code>HypothesisTests</code> (for <code>ShapiroWilkTest</code>) and <code>Statistics</code> (for <code>mean</code>).</li><li>If the total number of samples is less than <code>batch_size</code>, the function returns <code>NaN</code> (since there are no batches/p-values to average). Consider guarding against this in calling code.</li><li>The function assumes the presence of <code>noise_data(noise)</code>, which should return the vector of samples to test (e.g., <code>noise.ξ</code>). If not defined, replace <code>noise_data(noise)</code> with <code>noise.ξ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mika_method.jl#L231-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.point-Tuple{HistPeakAnalysis, Symbol, Symbol}" href="#Main.IonChannel.point-Tuple{HistPeakAnalysis, Symbol, Symbol}"><code>Main.IonChannel.point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point(hist::HistPeakAnalysis, indexfield::Symbol, valuefield::Symbol) -&gt; Point</code></pre><p>Extract a point (x, y) from a histogram analysis result using field names.</p><p><strong>Arguments</strong></p><ul><li><code>hist::HistPeakAnalysis</code>  </li></ul><p>A structurecontaining edges and value fields.</p><ul><li><code>indexfield::Symbol</code>  </li></ul><p>The field name indicating the index (e.g., <code>:pmax1_index</code>).</p><ul><li><code>valuefield::Symbol</code>  </li></ul><p>The field name indicating the value (e.g., <code>:pmax1</code>).</p><p><strong>Returns</strong></p><ul><li><a href="#Main.IonChannel.Point"><code>Point</code></a>  </li></ul><p>A <a href="#Main.IonChannel.Point"><code>Point</code></a> instance where <code>x</code> is taken from <code>hist.edges</code> at the specified index, and <code>y</code> is the field value accessed from <code>hist</code>.</p><p><strong>Description</strong></p><p>This function provides a generic way to extract coordinates from a histogram analysis result,  allowing flexible selection of peak or trough points for plotting or further calculations.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">analysis = analyze_histogram_peaks(prob_hist)
peak_pt = point(analysis, :pmax1_index, :pmax1)
println(peak_pt.x, &quot;, &quot;, peak_pt.y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mika_method.jl#L16-L44">source</a></section></article><h3 id="Deep-Channel-Method"><a class="docs-heading-anchor" href="#Deep-Channel-Method">Deep Channel Method</a><a id="Deep-Channel-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Deep-Channel-Method" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.deep_channel_method-Tuple{Vector{Float32}, Float32, DeepChannelMethod}" href="#Main.IonChannel.deep_channel_method-Tuple{Vector{Float32}, Float32, DeepChannelMethod}"><code>Main.IonChannel.deep_channel_method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deep_channel_method(data::Vector{Float32}, Δt::Float32, c_method::DeepChannelMethod) 
    :: DeepChannelMethodOutput</code></pre><p>Apply a deep learning–based ion-channel state detection method to time series data.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Float32}</code>: The raw time-series signal (e.g., ion-channel recording).</li><li><code>Δt::Float32</code>: Sampling interval of the signal. Used to convert sample indices into time units.</li><li><code>c_method::DeepChannelMethod</code>: A trained deep learning model encapsulated in a <a href="#Main.IonChannel.DeepChannelMethod"><code>DeepChannelMethod</code></a>  object. The underlying model must support <code>.predict</code>.</li></ul><p><strong>Returns</strong></p><p>A <a href="#Main.IonChannel.DeepChannelMethodOutput"><code>DeepChannelMethodOutput</code></a> containing:</p><ul><li><code>dwell_times_approx::Vector{Float32}</code>: Approximate dwell times (time spent in each state).</li><li><code>breakpoints::Vector{Float32}</code>: Time points where state transitions occur.</li><li><code>class_predict_val::Vector{UInt8}</code>: Per-sample predicted state labels, starting at <code>0</code>.</li></ul><p><strong>Method</strong></p><ol><li>The input data is scaled into <code>[0,1]</code> using <code>UnitRangeTransform</code>.</li><li>Data is reshaped into <code>(N,1,1,1)</code> to match the model’s expected input.</li><li>Predictions are computed with <code>c_method.model.predict</code>.</li><li>The most likely class per sample is extracted with <code>argmax</code>, producing <code>class_predict_val</code>.</li><li>Iterates through predictions to detect state transitions:<ul><li>Accumulates dwell times per state.</li><li>Records breakpoints at transitions.</li></ul></li><li>Returns dwell times, breakpoints, and the full predicted class sequence.</li></ol><p><strong>Notes</strong></p><ul><li>Predicted states are output as <code>UInt8</code> values starting from <code>0</code>.</li><li>Breakpoints and dwell times are expressed in the same units as <code>Δt</code>.</li><li><code>data_augmentation</code> is currently inactive but reserved for possible extensions.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">trace = rand(Float32, 10_000) # synthetic time-series
Δt = 0.1f0 # sampling interval
method = DeepChannelMethod(model) # previously constructed model

result = deep_channel_method(trace, Δt, method)

println(result.dwell_times_approx)
println(result.breakpoints)
println(result.class_predict_val[1:20])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/deep_channel_method.jl#L13-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.method_function-Tuple{DeepChannelMethod}" href="#Main.IonChannel.method_function-Tuple{DeepChannelMethod}"><code>Main.IonChannel.method_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">method_function(::DeepChannelMethod) -&gt; Function</code></pre><p>Return the algorithm function associated with a <a href="#Main.IonChannel.DeepChannelMethod"><code>DeepChannelMethod</code></a>.</p><p>This allows code like <code>calculate_method(data, m, Δt)</code> to work for any <a href="#Main.IonChannel.IdealizationMethod"><code>IdealizationMethod</code></a> subtype without changing the executor logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/deep_channel_method.jl#L3-L10">source</a></section></article><h3 id="Minimum-Description-Length-Method"><a class="docs-heading-anchor" href="#Minimum-Description-Length-Method">Minimum Description Length Method</a><a id="Minimum-Description-Length-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-Description-Length-Method" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel._mdl-Tuple{Vector{Float32}, Vector{UInt32}}" href="#Main.IonChannel._mdl-Tuple{Vector{Float32}, Vector{UInt32}}"><code>Main.IonChannel._mdl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_mdl(segment::Vector{Float32}, BP::Vector{UInt32}) :: Float32</code></pre><p>Compute the Minimum Description Length (MDL) criterion for a piecewise-constant segmentation.</p><p>Given a signal <code>segment</code> and a set of candidate breakpoint indices <code>BP</code>, this function evaluates the MDL cost consisting of a model complexity term and a data-fit term (residual sum of squares within segments). Lower values indicate better segmentations.</p><p>The segmentation is induced by the sorted, unique set <code>{1} ∪ BP ∪ {N}</code>, where <code>N = length(segment)</code>.</p><p>Arguments:</p><ul><li>segment::Vector{Float32}: The data segment to be evaluated.</li><li>BP::Vector{UInt32}: Candidate breakpoint indices (1-based, strictly within 1..N).</li></ul><p>Returns:</p><ul><li>Float32: The MDL value; lower is better. Returns <code>Inf</code> if the residual sum of squares (RSS) is non-positive.</li></ul><p>Details:</p><ul><li>For each segment between consecutive breakpoints, the mean is estimated and RSS accumulated.</li><li>Complexity term includes <code>p*log(N)</code> with <code>p = number_of_segments - 1</code>, and a local length penalty <code>0.5*Σ log(Nseg)</code>.</li><li>Fit term is <code>(N/2)*log(RSS/N)</code>.</li></ul><p>Notes:</p><ul><li>Empty subsegments are skipped when accumulating RSS and complexity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mdl.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel._test_breakpoint-Tuple{Vector{Float32}, Vector{UInt32}}" href="#Main.IonChannel._test_breakpoint-Tuple{Vector{Float32}, Vector{UInt32}}"><code>Main.IonChannel._test_breakpoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_test_breakpoint(segment::Vector{Float32}, candidate::Vector{UInt32}) :: Bool</code></pre><p>Test whether adding the proposed breakpoints reduces the MDL criterion.</p><p>Computes MDL with and without the candidate breakpoints and returns true if the candidate segmentation yields a strictly lower MDL score.</p><p>Arguments:</p><ul><li>segment::Vector{Float32}: Data segment to test.</li><li>candidate::Vector{UInt32}: Proposed breakpoint indices.</li></ul><p>Returns:</p><ul><li>Bool: <code>true</code> if <code>MDL(with candidate) &lt; MDL(without)</code>, otherwise <code>false</code>.</li></ul><p>Notes:</p><ul><li>Returns <code>false</code> when <code>candidate</code> is empty.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mdl.jl#L53-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.detect_breaks_mdl" href="#Main.IonChannel.detect_breaks_mdl"><code>Main.IonChannel.detect_breaks_mdl</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">detect_breaks_mdl(
    segment::Vector{Float32},
    method::AbstractString,
    min_seg::UInt16=UInt16(300)
) :: Vector{UInt32}</code></pre><p>Detect candidate breakpoint(s) using MDL-backed single or double-break search.</p><p>Depending on <code>method</code>, the function delegates to a single- or double-break detector and then validates the proposed breakpoints with the MDL test.</p><p>Arguments:</p><ul><li>segment::Vector{Float32}: Data to search for breakpoints.</li><li>method::AbstractString: Either <code>&quot;full&quot;</code> (single-break) or <code>&quot;full_two_break&quot;</code> (double-break).</li><li>min_seg::UInt16: Minimum allowed segment length (in samples).</li></ul><p>Returns:</p><ul><li>Vector{UInt32}: Validated breakpoint indices. Empty if none pass the MDL test or method is unknown.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mdl.jl#L80-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.detect_double_breakpoint" href="#Main.IonChannel.detect_double_breakpoint"><code>Main.IonChannel.detect_double_breakpoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">detect_double_breakpoint(
    data::Vector{Float32},
    min_seg::UInt16=UInt16(300)
) :: Vector{UInt32}</code></pre><p>Search for two change points that jointly minimize the sum of within-segment squared errors.</p><p>Uses cumulative sums to evaluate candidate pairs <code>(i, j)</code> efficiently, enforcing a minimum segment length on all three resulting segments.</p><p>Arguments:</p><ul><li>data::Vector{Float32}: Input signal.</li><li>min_seg::UInt16: Minimum segment length for each of the three segments.</li></ul><p>Returns:</p><ul><li>Vector{UInt32}: A 2-element vector <code>[i, j]</code> with the best breakpoints, or empty if none.</li></ul><p>Notes:</p><ul><li>If <code>length(data) &lt; 3*min_seg</code>, returns an empty vector without searching.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mdl.jl#L178-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.detect_single_breakpoint" href="#Main.IonChannel.detect_single_breakpoint"><code>Main.IonChannel.detect_single_breakpoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">detect_single_breakpoint(
    data::Vector{Float32},
    min_seg::UInt16=UInt16(300)
) :: Vector{UInt32}</code></pre><p>Find a single change point that minimizes within-segment squared error, subject to a minimum segment length.</p><p>Performs a linear scan, maintaining incremental means and within-segment sums of squares to identify the index that best splits the data into two segments with minimal total squared error.</p><p>Arguments:</p><ul><li>data::Vector{Float32}: Input sequence.</li><li>min_seg::UInt16: Minimum length for each side of the breakpoint.</li></ul><p>Returns:</p><ul><li>Vector{UInt32}: A vector with one breakpoint index, or empty if no valid split is found.</li></ul><p>Notes:</p><ul><li>If <code>length(data) &lt; 2*min_seg</code>, no split is attempted and the result is empty.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mdl.jl#L117-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.mdl_method-Tuple{Vector{Float32}, Float32, MDLMethod}" href="#Main.IonChannel.mdl_method-Tuple{Vector{Float32}, Float32, MDLMethod}"><code>Main.IonChannel.mdl_method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mdl_method(
    data::Vector{Float32},
    Δt::Float32,
    c_method::MDLMethod
) :: MDLMethodOutput</code></pre><p>Perform MDL-based idealization by iteratively detecting and validating breakpoints, filtering spurious changes by step size, and constructing the idealized state sequence.</p><p>Pipeline:</p><ol><li>Iterative breakpoint search:<ul><li>Starting from the full range, repeatedly detect single or double breakpoints (via <a href="#Main.IonChannel.detect_breaks_mdl"><code>detect_breaks_mdl</code></a>) within the current segment, respecting <code>c_method.min_seg</code>.</li><li>Accept and insert any proposed breakpoints that pass the MDL test.</li></ul></li><li>Sort and consolidate all local breakpoints.</li><li>Filter by jump magnitude:<ul><li>Use <code>stepstat_mdl(data, breaks, c_method.threshold)</code> to remove small steps and estimate segment means.</li></ul></li><li>Convert sample indices to time:<ul><li><code>breakpoints = final_breaks .* Δt</code>.</li></ul></li><li>Determine initial state using a histogram-derived threshold:<ul><li>Estimate amplitude threshold via <a href="#Main.IonChannel.histogram_calculator"><code>histogram_calculator</code></a>, <a href="#Main.IonChannel.calculate_probability_histogram-Tuple{StatsBase.Histogram}"><code>calculate_probability_histogram</code></a>, and <a href="#Main.IonChannel.analyze_histogram_peaks-Tuple{StatsBase.Histogram}"><code>analyze_histogram_peaks</code></a>, and set initial state to 0 if <code>data[1] &lt; threshold</code>, else 1.</li></ul></li><li>Build per-sample idealized sequence by alternating states across <code>final_breaks</code>.</li><li>Compute dwell times as <code>[breakpoints[1]; diff(breakpoints)]</code>.</li></ol><p>Arguments:</p><ul><li>data::Vector{Float32}: Input trace to be idealized.</li><li>Δt::Float32: Sampling interval used to convert indices to time.</li><li>c<em>method::MDLMethod: Configuration with `min</em>seg<code>,</code>threshold<code>, and</code>number<em>of</em>histogram_bins`.</li></ul><p>Returns:</p><ul><li>MDLMethodOutput: Contains <code>breakpoints</code> (Float32 times), <code>dwell_times_approx</code>, and <code>idealized_data</code> (UInt8 states).</li></ul><p>Notes:</p><ul><li>Expects the following helpers in scope: <a href="#Main.IonChannel.histogram_calculator"><code>histogram_calculator</code></a>, <a href="#Main.IonChannel.calculate_probability_histogram-Tuple{StatsBase.Histogram}"><code>calculate_probability_histogram</code></a>, and <a href="#Main.IonChannel.analyze_histogram_peaks-Tuple{StatsBase.Histogram}"><code>analyze_histogram_peaks</code></a> returning an object with fields <code>edges</code> and <code>pmin_index</code>.</li><li>State alternation assumes a two-state model (0/1) switching at each retained breakpoint.</li><li>If <code>final_breaks</code> is empty, ensure calling code handles empty dwell times accordingly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mdl.jl#L301-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.method_function-Tuple{MDLMethod}" href="#Main.IonChannel.method_function-Tuple{MDLMethod}"><code>Main.IonChannel.method_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">method_function(::MDLMethod)</code></pre><p>Dispatch helper that maps an <a href="#Main.IonChannel.MDLMethod"><code>MDLMethod</code></a> configuration to its execution function.</p><p>Returns a callable with signature <code>(data::Vector{Float32}, Δt::Float32, c_method::MDLMethod) -&gt; MDLMethodOutput</code>, typically used in higher-level code to select the appropriate idealization routine based on method type.</p><p>Example:</p><pre><code class="nohighlight hljs">f = method_function(MDLMethod(300, 0.8f0, 100))
out = f(data, Δt, c_method) # calls mdl_method</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mdl.jl#L406-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.stepstat_mdl" href="#Main.IonChannel.stepstat_mdl"><code>Main.IonChannel.stepstat_mdl</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stepstat_mdl(
    data::Vector{Float32},
    BP::Vector{UInt32},
    threshold::Float32=0.8f0
) :: Tuple{Vector{UInt32}, Vector{Float32}}</code></pre><p>Estimate step values per segment and filter breakpoints by jump magnitude.</p><p>Given breakpoints <code>BP</code>, this function:</p><ul><li>appends the end index to form closed segments,</li><li>estimates the mean (<code>stepvalue</code>) for each segment,</li><li>computes jumps between consecutive segment means,</li><li>filters breakpoints whose absolute jump exceeds <code>threshold</code>.</li></ul><p>Arguments:</p><ul><li>data::Vector{Float32}: Input signal.</li><li>BP::Vector{UInt32}: Candidate breakpoints (1-based).</li><li>threshold::Float32: Minimum absolute difference between consecutive step means to retain a breakpoint.</li></ul><p>Returns:</p><ul><li>(filtered::Vector{UInt32}, stepvalue::Vector{Float32}):<ul><li><code>filtered</code>: Breakpoints surviving the jump threshold.</li><li><code>stepvalue</code>: Estimated mean level for each (original) segment.</li></ul></li></ul><p>Notes:</p><ul><li>Ensures each segment has at least one index; if an interval collapses, it uses the breakpoint index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/mdl.jl#L248-L275">source</a></section></article><h2 id="Accuracy-of-methods"><a class="docs-heading-anchor" href="#Accuracy-of-methods">Accuracy of methods</a><a id="Accuracy-of-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Accuracy-of-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.accuracy_of_idealization-Tuple{Vector{UInt8}, Vector{UInt8}}" href="#Main.IonChannel.accuracy_of_idealization-Tuple{Vector{UInt8}, Vector{UInt8}}"><code>Main.IonChannel.accuracy_of_idealization</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">accuracy_of_idealization(
    actual_idealization::Vector{UInt8},
    approx_idealization::Vector{UInt8}
) :: Float32</code></pre><p>Compute the accuracy of an approximate idealization compared to the ground-truth (or reference) idealization.</p><p><strong>Arguments</strong></p><ul><li><code>actual_idealization::Vector{UInt8}</code>: The reference (true) idealized signal,  represented as a binary vector (<code>0</code> and <code>1</code> states).</li><li><code>approx_idealization::Vector{UInt8}</code>: The test or approximated idealized trace  to be evaluated.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: The accuracy, computed as the proportion of matching states between the two sequences, in the range <code>[0.0, 1.0]</code>.</li></ul><p><strong>Method</strong></p><ol><li>If the first state of <code>approx_idealization</code> does not match the first state of <code>actual_idealization</code>, then <code>approx_idealization</code> is inverted (<code>0 ↔ 1</code>) to ensure label consistency.</li><li>Accuracy is calculated as:  <code>sum(actual_idealization .== approx_idealization) / length(approx_idealization)</code>  i.e., the fraction of samples where both sequences agree.</li></ol><p><strong>Notes</strong></p><pre><code class="nohighlight hljs">- This function assumes both inputs are of equal length.
- If a systematic state-label swap occurred (e.g., model outputs `1` for &quot;closed&quot;
but reference uses `0`), the inversion step ensures a fair comparison.
- Accuracy is a simple per-sample metric and may not capture temporal
misalignments (e.g., small shifts in breakpoints).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/method_mse.jl#L190-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.actual_idealize_data-Tuple{Dict{String, Vector{Float32}}, Dict{String, Int64}, AbstractString, Float32}" href="#Main.IonChannel.actual_idealize_data-Tuple{Dict{String, Vector{Float32}}, Dict{String, Int64}, AbstractString, Float32}"><code>Main.IonChannel.actual_idealize_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">actual_idealize_data(
    data::Dict{String, Vector{Float32}},
    what_first_dict::Dict{String, Int64},
    data_file_name::AbstractString,
    Δt::Float32
) :: Vector{UInt8}</code></pre><p>Reconstruct a binary idealized signal from dwell-time information by alternating between states <code>0</code> and <code>1</code> with durations matching the provided dwell times.</p><p><strong>Arguments</strong></p><ul><li><code>data::Dict{String, Vector{Float32}}</code>: Dictionary containing at least:<ul><li><code>&quot;dwell times&quot;</code>: a vector of dwell time durations for consecutive states.</li><li><code>&quot;x&quot;</code>: the original data trace (used to match output length).</li></ul></li><li><code>what_first_dict::Dict{String, Int64}</code>: Dictionary specifying the starting  state for each file, mapped by file name.</li><li><code>data_file_name::AbstractString</code>: Name of the dataset; used to select  the initial state from <code>what_first_dict</code>.</li><li><code>Δt::Float32</code>: Sampling interval of the signal; used to convert dwell  durations into sample counts.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{UInt8}</code>: A binary idealized trace of the same length as <code>data[&quot;x&quot;]</code>,  representing predicted open/closed states (<code>0</code>/<code>1</code>).</li></ul><p><strong>Method</strong></p><ol><li>Retrieve the starting state (<code>what_first</code>) from <code>what_first_dict</code> for the current file.</li><li>Initialize <code>idealized_values</code> with that state.</li><li>For each dwell time in <code>data[&quot;dwell times&quot;]</code>:<ul><li>Convert dwell duration into a number of samples: <code>how_many = round(Int, dt / Δt)</code>.</li><li>Append that many samples of the current state.</li><li>Switch to the opposite state (<code>0 → 1</code> or <code>1 → 0</code>).</li><li>Ensure at least one sample is generated for very small dwell times.</li></ul></li><li>Adjust the length of the result:<ul><li>If longer than <code>data[&quot;x&quot;]</code>, truncate.</li><li>If shorter, pad with the next state to match the signal length.</li></ul></li><li>Return the finalized binary idealized trace.</li></ol><p><strong>Notes</strong></p><ul><li>The function enforces that the returned vector always matches the length of the original recorded trace (<code>data[&quot;x&quot;]</code>).</li><li>Alternating states assumes a two-state system (<code>0</code> and <code>1</code>), which is standard in patch-clamp idealization.</li><li>Handles dwell durations shorter than <code>Δt</code> by ensuring at least one sample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/method_mse.jl#L125-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.calculate_mean_square_error" href="#Main.IonChannel.calculate_mean_square_error"><code>Main.IonChannel.calculate_mean_square_error</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_mean_square_error(
    data::Dict{String, Vector{Float32}}, 
    dwell_times_approx::Vector{Float32}, 
    dt_bins::UInt16=100
) -&gt; Tuple{Float32, Histogram, Histogram}</code></pre><p>Calculate the mean squared error (MSE) between histograms of actual and approximate dwell times,  and return both histograms for further analysis.</p><p><strong>Arguments</strong></p><ul><li><code>data::Dict{String, Vector{Float32}}</code>  </li></ul><p>A dictionary containing at least the key <code>&quot;dwell times&quot;</code> mapped to a vector of observed dwell times (Float32).</p><ul><li><code>dwell_times_approx::Vector{Float32}</code>  </li></ul><p>A vector of approximate dwell times to compare against the observed data.</p><ul><li><code>dt_bins::UInt16</code> (optional, default=<code>100</code>)  </li></ul><p>Number of bins to use when computing histograms for error calculation.</p><p><strong>Returns</strong></p><p><code>Tuple{Float32, Histogram, Histogram}</code> — <code>(mse, hist_data, hist_approx)</code> where:</p><ol><li><code>mse::Float32</code>  </li></ol><p>Mean squared error between the histogram bin counts of actual and approximate dwell times.   Computed as the average squared difference in bin weights.</p><ol><li><code>hist_data::Histogram</code>  </li></ol><p>Histogram of actual dwell times from <code>data[&quot;dwell times&quot;]</code>.</p><ol><li><code>hist_approx::Histogram</code>  </li></ol><p>Histogram of <code>dwell_times_approx</code>.</p><p><strong>Description</strong></p><ol><li>Creates histograms for both <strong>actual</strong> (<code>data[&quot;dwell times&quot;]</code>) and <strong>approximate</strong> dwell times using <a href="#Main.IonChannel.histogram_calculator"><code>histogram_calculator</code></a>.</li><li>Fits exponential distributions to each dataset and computes differences in the fitted scale parameters (<code>θ</code> values).</li><li>Calculates the MSE between the histogram weights of the actual and approximate dwell times.</li><li>Returns the MSE along with both histogram objects for plotting or further analysis.</li></ol><p><strong>Notes</strong></p><ul><li>Uses <code>StatsBase</code> for histogram handling and <code>fit_mle</code> from <code>Distributions</code> for maximum likelihood estimation.</li><li>The intermediate variables <code>breakpoints</code> and <code>accuracy</code> are currently computed but not returned.</li><li>The returned histograms can be directly plotted with <code>Plots.jl</code> or analyzed further.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using Distributions, StatsBase

data = Dict(&quot;dwell times&quot; =&gt; rand(Exponential(1.0), 1000))
dwell_times_approx = rand(Exponential(1.1), 1000)

mse, h_data, h_approx = calculate_mean_square_error(data, dwell_times_approx, 50)

println(&quot;Mean squared error: &quot;, mse)
display(h_data)
display(h_approx)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/method_mse.jl#L6-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.dicts_to_dataframes-Tuple{Dict{String, Dict{String, Vector{Float32}}}, Dict{String, Float32}, Dict{String, Float32}}" href="#Main.IonChannel.dicts_to_dataframes-Tuple{Dict{String, Dict{String, Vector{Float32}}}, Dict{String, Float32}, Dict{String, Float32}}"><code>Main.IonChannel.dicts_to_dataframes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dicts_to_dataframes(table::Dict{String,Dict{String,Vector{Float32}}},
                    mean_accuracy_dict::Dict{String,Float32},
                    mean_error_dict::Dict{String,Float32}) -&gt; Tuple{DataFrame,DataFrame,DataFrame}</code></pre><p>Return (df<em>errors, df</em>accuracies, df_summary) as DataFrames.</p><ul><li>df_errors: columns per voltage with MSE values (missing padded).</li><li>df_accuracies: columns per voltage with accuracy values (missing padded).</li><li>df<em>summary: one row per voltage with mean</em>error and mean_accuracy.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/method_mse.jl#L355-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.idealize_data-Tuple{Vector{Float32}, Vector{Float32}, HistPeakAnalysis, Float32}" href="#Main.IonChannel.idealize_data-Tuple{Vector{Float32}, Vector{Float32}, HistPeakAnalysis, Float32}"><code>Main.IonChannel.idealize_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">idealize_data(data::Vector{Float32}, dwell_times_approx::Vector{Float32}, hist_analysis::HistPeakAnalysis, Δt::Float32) -&gt; Vector{UInt8}</code></pre><p>Construct an idealized signal from approximate dwell times and histogram peak analysis.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Float32}</code>  </li></ul><p>The original raw data signal.</p><ul><li><code>dwell_times_approx::Vector{Float32}</code>  </li></ul><p>Approximate dwell times computed by an idealization method, in seconds.</p><ul><li><code>hist_analysis::HistPeakAnalysis</code>  </li></ul><p>Result of histogram peak analysis providing peak intensities and midpoint for thresholding.</p><ul><li><code>Δt::Float32</code>  </li></ul><p>Sampling interval of the data, in seconds.</p><p><strong>Returns</strong></p><ul><li><code>Vector{UInt8}</code>  </li></ul><p>Idealized signal reconstructed by alternating between the two states 0 and 1, segmented according to the provided dwell times and aligned in length with the original data.</p><p><strong>Description</strong></p><p>This function assigns each dwell segment one of two peak intensities depending on which side of the midpoint the starting value lies. It alternates between these intensities for consecutive dwell segments. The output length matches the input data by truncation or padding.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">ideal_signal = idealize_data(data, dwell_times_approx, hist_analysis, Δt)
plot(data, label=&quot;Raw data&quot;)
plot!(ideal_signal, label=&quot;Idealized signal&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/method_mse.jl#L71-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.mean_error" href="#Main.IonChannel.mean_error"><code>Main.IonChannel.mean_error</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean_error(method::IdealizationMethod, Δt::Float32, data_size::UInt32, ::Bool=false) -&gt; Tuple{Dict{String, Dict{String, Vector{Float32}}}, Dict{String, Float32}, Dict{String, Float32}}</code></pre><p>Compute the <strong>average mean squared error (MSE)</strong> across multiple datasets, using a specified idealization method to approximate dwell times.</p><p><strong>Arguments</strong></p><ul><li><code>method::IdealizationMethod</code>  </li></ul><p>An instance of a concrete subtype of <a href="#Main.IonChannel.IdealizationMethod"><code>IdealizationMethod</code></a>,   such as <a href="#Main.IonChannel.MeanDeviationMethod"><code>MeanDeviationMethod</code></a>, which stores:     - The dwell-time estimation function.     - Method parameters (e.g. δ, λ values).</p><ul><li><code>Δt::Float32</code>  </li></ul><p>Sampling interval (seconds) of the recordings.</p><ul><li><code>data_size::UInt32</code></li></ul><p>Number of data points to include in each dataset for MSE calculation.</p><ul><li><code>verbose::Bool=false</code></li></ul><p>If <code>true</code>, prints detailed processing information for each dataset.</p><p><strong>Returns</strong></p><ul><li><code>Tuple{Dict{String, Dict{String, Vector{Float32}}}, Dict{String, Float32}, Dict{String, Float32}}</code>:  <ul><li>A dictionary with keys <code>&quot;errors&quot;</code> and <code>&quot;accuracies&quot;</code>, each mapping to another dictionary where:<ul><li>Keys are voltage levels (as strings).</li><li>Values are vectors of MSE or accuracy values for each dataset at that voltage.</li></ul></li><li>A dictionary mapping voltage levels to their mean accuracy across datasets.</li><li>A dictionary mapping voltage levels to their mean MSE across datasets.</li></ul></li></ul><p><strong>Description</strong></p><ol><li>Uses <a href="#Main.IonChannel.read_all_file_paths-Tuple{String}"><code>read_all_file_paths</code></a> to find all raw data and dwell time files.</li><li>For each dataset:</li></ol><ul><li>Loads raw data (<code>x</code>) and actual dwell times (<code>y</code>).</li><li>Truncates data to desired length via <a href="#Main.IonChannel.get_specified_datapoints"><code>get_specified_datapoints</code></a>.</li><li>Normalizes the <code>&quot;x&quot;</code> signal using <a href="#Main.IonChannel.normalize_data-Tuple{Dict{String, Vector{Float32}}}"><code>normalize_data</code></a>.</li><li>Estimates dwell times by calling <a href="#Main.IonChannel.calculate_method-Tuple{Vector{Float32}, IdealizationMethod, Float32}"><code>calculate_method</code></a>     with the normalized data, <code>method</code>, and <code>Δt</code>.</li><li>Computes the MSE between actual and estimated dwell times   via <a href="#Main.IonChannel.calculate_mean_square_error"><code>calculate_mean_square_error</code></a>, taking only the MSE value   (first element of its tuple return).</li></ul><ol><li>Averages the per-dataset MSE values.</li></ol><p><strong>Notes</strong></p><ul><li>This function assumes the folder <code>&quot;data&quot;</code> exists and has the expected  </li></ul><p>subfolder structure required by <a href="#Main.IonChannel.read_all_file_paths-Tuple{String}"><code>read_all_file_paths</code></a>.</p><ul><li>The helper <a href="#Main.IonChannel.calculate_method-Tuple{Vector{Float32}, IdealizationMethod, Float32}"><code>calculate_method</code></a> is responsible for interpreting  </li></ul><p>the <a href="#Main.IonChannel.IdealizationMethod"><code>IdealizationMethod</code></a> instance and calling its stored method function.</p><ul><li>The <code>&quot;x&quot;</code> and <code>&quot;dwell times&quot;</code> vectors are assumed to be aligned and compatible.</li><li><a href="#Main.IonChannel.calculate_mean_square_error"><code>calculate_mean_square_error</code></a> now returns a tuple; only the first element is used.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">m = MeanDeviationMethod(deviation_from_mean_method, 0.05, 0.5)
Δt = 1e-4
avg_mse = mean_error(m, Δt, UInt32(10000))
println(&quot;Average MSE across datasets: &quot;, avg_mse)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/method_mse.jl#L234-L289">source</a></section></article><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.plot_idealization_representation-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}" href="#Main.IonChannel.plot_idealization_representation-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}"><code>Main.IonChannel.plot_idealization_representation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_idealization_representation(data::Dict{String, Vector{Float32}}, method_output::MethodOutput, T_left::Float32, T_right::Float32, Δt::Float32)</code></pre><p>Visualize ion channel data and its idealization using stacked subplots.   Supports <a href="#Main.IonChannel.MikaMethodOutput"><code>MikaMethodOutput</code></a> and <a href="#Main.IonChannel.MeanDeviationMethodOutput"><code>MeanDeviationMethodOutput</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>data::Dict{String, Vector{Float32}}</code>  </li></ul><p>Dictionary containing <code>&quot;x&quot;</code> (raw signal data) and associated fields as needed.</p><ul><li><code>method_output::MethodOutput</code>  </li></ul><p>Output of an idealization algorithm. If it is <a href="#Main.IonChannel.MikaMethodOutput"><code>MikaMethodOutput</code></a>, uses the built-in idealized data; if <a href="#Main.IonChannel.MeanDeviationMethodOutput"><code>MeanDeviationMethodOutput</code></a>, reconstructs the idealization using dwell times and histogram analysis.</p><ul><li><code>T_left::Float32</code></li></ul><p>Start time (seconds) for the plot interval.</p><ul><li><code>T_right::Float32</code>  </li></ul><p>Total plot duration (seconds).</p><ul><li><code>Δt::Float32</code>  </li></ul><p>Sampling interval (seconds).</p><p><strong>Description</strong></p><p>Creates a two-row subplot:</p><ul><li><strong>Top plot:</strong> Raw ion channel current signal (<code>data[&quot;x&quot;]</code>) in green.</li><li><strong>Bottom plot:</strong> Idealized signal in blue.<ul><li>For Mika methods: uses <code>method_output.idealized_data</code>.</li><li>For Mean Deviation methods: reconstructs idealization using dwell times and peak analysis.</li></ul></li></ul><p>Axes are labeled by time and current.   Legend is suppressed for clarity.   Other idealization outputs can be supported by extending the function.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs"># For Mika idealization
plot_idealization_representation(data, mika_output, 0.5, 1.0, 1e-4)

# For mean deviation idealization
plot_idealization_representation(data, mean_deviation_output, 0.5, 1.0, 1e-4)</code></pre><p><strong>Note</strong></p><p>For <a href="#Main.IonChannel.MeanDeviationMethodOutput"><code>MeanDeviationMethodOutput</code></a>, histogram calculation and peak analysis are rerun to reconstruct the idealized trace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/visualization.jl#L70-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.show_approx_on_plot-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}" href="#Main.IonChannel.show_approx_on_plot-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}"><code>Main.IonChannel.show_approx_on_plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>show<em>approx</em>on<em>plot(data::Dict{String, Vector{Float32}}, method</em>output::MethodOutput, T<em>left::Float32, T</em>right::Float32, Δt::Float32)</p><p>Plot raw data and overlay exact (ground truth) and approximated (idealized) breakpoints, with threshold line for Mika methods.</p><p><strong>Arguments</strong></p><ul><li><code>data::Dict{String, Vector{Float32}}</code>  </li></ul><p>Dictionary containing <code>&quot;x&quot;</code> (raw data signal) and <code>&quot;dwell times&quot;</code> (vector of dwell segment durations).</p><ul><li><code>method_output::MethodOutput</code>  </li></ul><p>Output from an idealization algorithm, providing breakpoints and (for Mika) threshold information.</p><ul><li><code>T_left::Float32</code></li></ul><p>Start time (seconds) for the plot interval.</p><ul><li><code>T_right::Float32</code>  </li></ul><p>End time (seconds) for the plot interval.</p><ul><li><code>Δt::Float32</code>  </li></ul><p>Sampling interval (seconds).</p><p><strong>Description</strong></p><p>Plots the time series <code>&quot;x&quot;</code> for the duration <code>[T_left, T_right]</code> as a green line.  </p><ul><li><strong>Red vertical lines:</strong> Mark true breakpoints, based on cumulative dwell times from <code>T_left</code> to <code>T_right</code>.</li><li><strong>Blue vertical lines:</strong> Indicate approximated breakpoints detected by the idealization method, up to from <code>T_left</code> to <code>T_right</code>.</li><li><strong>Threshold band:</strong> If the <code>method_output</code> is a <a href="#Main.IonChannel.MikaMethodOutput"><code>MikaMethodOutput</code></a>, overlays 2 horizontal lines representing thresold <code>x₁</code> and <code>x₂</code>.</li></ul><p>Line opacities scale with the interval length.   Additional features—such as band limits or idealized data overlay—can be enabled by uncommenting code sections.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">show_approx_on_plot(data, result, 0.5, 0.9, 1e-4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/visualization.jl#L4-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.show_threshold_on_plot-Tuple{StatsBase.Histogram, HistPeakAnalysis, MikaMethodOutput}" href="#Main.IonChannel.show_threshold_on_plot-Tuple{StatsBase.Histogram, HistPeakAnalysis, MikaMethodOutput}"><code>Main.IonChannel.show_threshold_on_plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">show_threshold_on_plot(data_histogram::Histogram, histogram_analysis::HistPeakAnalysis, method_output::MikaMethodOutput)</code></pre><p>Plot the data histogram and visualize threshold-related features and detected peaks.</p><p><strong>Arguments</strong></p><ul><li><code>data_histogram::Histogram</code>  </li></ul><p>The histogram of original data, typically created with <a href="#Main.IonChannel.histogram_calculator"><code>histogram_calculator</code></a>.</p><ul><li><code>histogram_analysis::HistPeakAnalysis</code>  </li></ul><p>Results from peak and minimum detection, providing bin indices for annotated visualization.</p><ul><li><code>method_output::MikaMethodOutput</code>  </li></ul><p>Output of the Mika method containing the chosen threshold index and other results.</p><p><strong>Description</strong></p><p>Creates a bar plot of the data histogram and overlays vertical lines to indicate:</p><ul><li>the primary and secondary peaks,</li><li>the histogram midpoint,</li><li>the selected threshold band location,</li><li>and the minimum between peaks.</li></ul><p>This visualization helps evaluate the effectiveness and placement of the threshold and key features used by the idealization algorithm.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">show_threshold_on_plot(data_histogram, analysis, result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/visualization.jl#L134-L160">source</a></section></article><h2 id="Additional-functions"><a class="docs-heading-anchor" href="#Additional-functions">Additional functions</a><a id="Additional-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.analyze_histogram_peaks-Tuple{StatsBase.Histogram}" href="#Main.IonChannel.analyze_histogram_peaks-Tuple{StatsBase.Histogram}"><code>Main.IonChannel.analyze_histogram_peaks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">analyze_histogram_peaks(prob_hist::Histogram) -&gt; HistPeakAnalysis</code></pre><p>Analyze a probability histogram to find the indices and values of major peaks and the trough between them.</p><p><strong>Arguments</strong></p><ul><li><code>prob_hist::Histogram</code>  </li></ul><p>A probability histogram (from <code>StatsBase.Histogram</code>), typically with normalized weights.</p><p><strong>Returns</strong></p><ul><li><a href="#Main.IonChannel.HistPeakAnalysis"><code>HistPeakAnalysis</code></a>  </li></ul><p>A structure bundling bin edges, weights, indices and values for the two main peaks, the midpoint index, and the minimum value (trough) between the peaks.</p><p><strong>Description</strong></p><p>This function examines the provided histogram to determine the location and values of:</p><ul><li>The primary maximum (<code>pmax1</code>)</li><li>The secondary maximum (<code>pmax2</code>)</li><li>The midpoint index between the two maxima</li><li>The minimum value (<code>pmin</code>) found between those peaks (used for thresholding)</li></ul><p>All results are packed into a <a href="#Main.IonChannel.HistPeakAnalysis"><code>HistPeakAnalysis</code></a> struct for downstream use.</p><p><strong>Example</strong></p><p>data = randn(1000) hist = fit(Histogram, data, 50) prob<em>hist = calculate</em>probability<em>histogram(hist) analysis = analyze</em>histogram<em>peaks(prob</em>hist)</p><p>println(&quot;First peak: &quot;, analysis.pmax1, &quot; at index &quot;, analysis.pmax1<em>index) println(&quot;Second peak: &quot;, analysis.pmax2, &quot; at index &quot;, analysis.pmax2</em>index) println(&quot;Minimum between peaks: &quot;, analysis.pmin, &quot; at index &quot;, analysis.pmin_index) ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/auxiliary.jl#L165-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.calculate_method-Tuple{Vector{Float32}, IdealizationMethod, Float32}" href="#Main.IonChannel.calculate_method-Tuple{Vector{Float32}, IdealizationMethod, Float32}"><code>Main.IonChannel.calculate_method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_method(data::Vector{Float32}, c_method::IdealizationMethod, Δt::Float32)</code></pre><p>Run the dwell-time estimation algorithm associated with the given method type.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Float32}</code> - The signal to analyse.</li><li><code>m::IdealizationMethod</code> - Parameters for the chosen method; algorithm resolved by <code>method(m)</code>.</li><li><code>Δt::Float32</code> - Sampling interval in seconds.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float32}</code> - Dwell times detected by the chosen method.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">m = MeanDeviationMethod(0.05, 0.5)
dwell_times = calculate_dwell_times(signal, m, 1e-4)  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/auxiliary.jl#L235-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.calculate_probability_histogram-Tuple{StatsBase.Histogram}" href="#Main.IonChannel.calculate_probability_histogram-Tuple{StatsBase.Histogram}"><code>Main.IonChannel.calculate_probability_histogram</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>calculate<em>probability</em>histogram(histogram::Histogram) -&gt; Histogram</p><p>Convert the counts in a histogram to probabilities, producing a probability histogram.</p><p><strong>Arguments</strong></p><ul><li><code>histogram::Histogram</code>  </li></ul><p>A histogram object (from <code>StatsBase</code>) containing bin edges and weighted counts.</p><p><strong>Returns</strong></p><ul><li><code>Histogram</code>  </li></ul><p>A new histogram object with the same bin edges as the input, but with weights normalized to sum to 1, representing probabilities.</p><p><strong>Description</strong></p><p>This function takes a histogram of counts or weights and converts it to a probability histogram by dividing each bin’s weight by the total sum of all bin weights.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">data = randn(1000)
hist = fit(Histogram, data, 50)
prob_hist = calculate_probability_histogram(hist)

println(sum(prob_hist.weights)) # Should print 1.0 (or very close due to floating point)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/auxiliary.jl#L130-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.create_idealizations" href="#Main.IonChannel.create_idealizations"><code>Main.IonChannel.create_idealizations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>create<em>idealizations(data</em>folder::String, Δt::Float32) -&gt; Dict{String, Vector{Int8}}</p><p>Generate idealized binary traces from raw experimental data and dwell times.</p><p>This function reads data files and their associated dwell time files from a given folder (using <a href="#Main.IonChannel.read_all_file_paths-Tuple{String}"><code>read_all_file_paths</code></a>), then produces idealized sequences of <code>0</code> and <code>1</code> values based on the dwell times and initial state information.</p><p><strong>Arguments</strong></p><ul><li><code>data_folder::String</code>: Path to the main data directory.  </li></ul><p>Must follow the folder structure expected by <a href="#Main.IonChannel.read_all_file_paths-Tuple{String}"><code>read_all_file_paths</code></a>, with subfolders:</p><ul><li><code>sampling/&lt;voltage&gt;/</code></li><li><code>dwell_times/&lt;voltage&gt;/</code></li></ul><p>and an additional file at the top level used to determine the starting state for each trace.</p><ul><li><code>Δt::Float32</code> (optional, default=1e-4): Time step in seconds used to convert dwell times to point counts.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String, Vector{Int8}}</code>:  </li></ul><p>A dictionary where:</p><ul><li>Keys are <strong>file names</strong> (without path) of the raw data files.</li><li>Values are idealized traces (<code>Vector{Int8}</code>), where elements are <code>0</code> or <code>1</code>.</li></ul><p><strong>Method</strong></p><ol><li>Calls <a href="#Main.IonChannel.read_all_file_paths-Tuple{String}"><code>read_all_file_paths</code></a> to get:</li></ol><ul><li>Path to the &quot;first state&quot; file (<code>what_first_path</code>)</li><li>List of raw data file paths</li><li>List of dwell times file paths</li></ul><ol><li>Reads the initial states for each trace from the &quot;first state&quot; file.</li><li>For each dataset:</li></ol><ul><li>Reads raw signal (<code>x</code>) and dwell times (<code>y</code>).</li><li>Constructs a binary vector that alternates between <code>0</code> and <code>1</code> according to the dwell times.</li><li>Ensures the idealized vector length matches the raw data length by trimming or padding as necessary.</li></ul><ol><li>Stores the idealized vector in the result dictionary under the base file name of the dataset.</li></ol><p><strong>Example</strong></p><pre><code class="nohighlight hljs">idealized = create_idealizations(&quot;experiment_data&quot;)
println(keys(idealized)) # List of processed file names
println(idealized[&quot;trace01.dat&quot;][1:20]) # First 20 idealized points of a trace</code></pre><p><strong>Notes</strong></p><ul><li>The time step <code>Δt</code> is fixed at <code>1e-4</code> seconds.</li><li>Dwell times are converted to integer point counts via <code>round(Int, dt/Δt)</code>.</li><li>If a computed segment length is <code>0</code>, it is replaced with a segment of length <code>1</code>.</li><li>If the total length exceeds the raw signal length, the idealized trace is truncated;  </li></ul><p>otherwise, zeros or ones are appended to match the length.</p><ul><li>Switching between <code>0</code> and <code>1</code> starts from the value given in the <code>what_first_path</code> file</li></ul><p>for the specific trace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/auxiliary.jl#L4-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.IonChannel.histogram_calculator" href="#Main.IonChannel.histogram_calculator"><code>Main.IonChannel.histogram_calculator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>histogram_calculator(data::Vector{Float32}, bins::UInt16=100) -&gt; Histogram</p><p>Compute a histogram of the given data vector with a specified number of bins.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Float32}</code>: A vector of floating-point numbers representing the data to histogram.</li><li><code>bins::UInt16</code> (optional, default=100): Number of bins to divide the data range into.</li></ul><p><strong>Returns</strong></p><ul><li><code>Histogram</code>: A <code>Histogram</code> object (from <code>StatsBase.jl</code>) representing the frequency distribution</li></ul><p>of the data across the specified bins.</p><p><strong>Method</strong></p><ol><li>Determine the minimum (<code>min_data</code>) and maximum (<code>max_data</code>) values in the data.</li><li>Divide the interval [<code>min_data</code>, <code>max_data</code>] into <code>bins</code> equal-width bins.</li><li>Use <code>StatsBase.fit(Histogram, data, edges)</code> to compute the histogram counts and bin edges.</li><li>Return the histogram object.</li></ol><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using StatsBase

data = randn(1000) # 1000 samples from a normal distribution
hist = histogram_calculator(data, UInt16(50))
println(hist.weights) # Counts per bin
println(hist.edges) # Bin edges</code></pre><p><strong>Notes</strong></p><ul><li>Requires <code>StatsBase.jl</code> for the <code>Histogram</code> type and <code>fit</code> function.</li><li>The bins are equally spaced between the minimum and maximum data values.</li><li>The returned <code>Histogram</code> object contains bin edges and counts, suitable for further analysis or plotting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/University-of-Silesia-Ion-Channel/IonChannel.jl/blob/883cc14716980c7ceefecda0fd25983192ed7f8e/src/auxiliary.jl#L88-L121">source</a></section></article><ul><li><a href="#IonChannel"><code>IonChannel</code></a></li><li><a href="#Main.IonChannel.DeepChannelMethod"><code>Main.IonChannel.DeepChannelMethod</code></a></li><li><a href="#Main.IonChannel.DeepChannelMethodOutput"><code>Main.IonChannel.DeepChannelMethodOutput</code></a></li><li><a href="#Main.IonChannel.HistPeakAnalysis"><code>Main.IonChannel.HistPeakAnalysis</code></a></li><li><a href="#Main.IonChannel.IdealizationMethod"><code>Main.IonChannel.IdealizationMethod</code></a></li><li><a href="#Main.IonChannel.Line"><code>Main.IonChannel.Line</code></a></li><li><a href="#Main.IonChannel.MDLMethod"><code>Main.IonChannel.MDLMethod</code></a></li><li><a href="#Main.IonChannel.MDLMethodOutput"><code>Main.IonChannel.MDLMethodOutput</code></a></li><li><a href="#Main.IonChannel.MeanDeviationMethod"><code>Main.IonChannel.MeanDeviationMethod</code></a></li><li><a href="#Main.IonChannel.MeanDeviationMethodOutput"><code>Main.IonChannel.MeanDeviationMethodOutput</code></a></li><li><a href="#Main.IonChannel.MeanError"><code>Main.IonChannel.MeanError</code></a></li><li><a href="#Main.IonChannel.MethodOutput"><code>Main.IonChannel.MethodOutput</code></a></li><li><a href="#Main.IonChannel.MikaMethod"><code>Main.IonChannel.MikaMethod</code></a></li><li><a href="#Main.IonChannel.MikaMethodOutput"><code>Main.IonChannel.MikaMethodOutput</code></a></li><li><a href="#Main.IonChannel.NaiveMethod"><code>Main.IonChannel.NaiveMethod</code></a></li><li><a href="#Main.IonChannel.NaiveMethodOutput"><code>Main.IonChannel.NaiveMethodOutput</code></a></li><li><a href="#Main.IonChannel.Noise"><code>Main.IonChannel.Noise</code></a></li><li><a href="#Main.IonChannel.Point"><code>Main.IonChannel.Point</code></a></li><li><a href="#Main.IonChannel.ThresholdWidth"><code>Main.IonChannel.ThresholdWidth</code></a></li><li><a href="#Main.IonChannel._mdl-Tuple{Vector{Float32}, Vector{UInt32}}"><code>Main.IonChannel._mdl</code></a></li><li><a href="#Main.IonChannel._test_breakpoint-Tuple{Vector{Float32}, Vector{UInt32}}"><code>Main.IonChannel._test_breakpoint</code></a></li><li><a href="#Main.IonChannel.accuracy_of_idealization-Tuple{Vector{UInt8}, Vector{UInt8}}"><code>Main.IonChannel.accuracy_of_idealization</code></a></li><li><a href="#Main.IonChannel.actual_idealize_data-Tuple{Dict{String, Vector{Float32}}, Dict{String, Int64}, AbstractString, Float32}"><code>Main.IonChannel.actual_idealize_data</code></a></li><li><a href="#Main.IonChannel.analyze_histogram_peaks-Tuple{StatsBase.Histogram}"><code>Main.IonChannel.analyze_histogram_peaks</code></a></li><li><a href="#Main.IonChannel.calculate_approximation-Tuple{Vector{Tuple{Float32, Float32}}, ThresholdWidth}"><code>Main.IonChannel.calculate_approximation</code></a></li><li><a href="#Main.IonChannel.calculate_mean_square_error"><code>Main.IonChannel.calculate_mean_square_error</code></a></li><li><a href="#Main.IonChannel.calculate_method-Tuple{Vector{Float32}, IdealizationMethod, Float32}"><code>Main.IonChannel.calculate_method</code></a></li><li><a href="#Main.IonChannel.calculate_probability_histogram-Tuple{StatsBase.Histogram}"><code>Main.IonChannel.calculate_probability_histogram</code></a></li><li><a href="#Main.IonChannel.combine_time_with_data"><code>Main.IonChannel.combine_time_with_data</code></a></li><li><a href="#Main.IonChannel.create_idealizations"><code>Main.IonChannel.create_idealizations</code></a></li><li><a href="#Main.IonChannel.deep_channel_method-Tuple{Vector{Float32}, Float32, DeepChannelMethod}"><code>Main.IonChannel.deep_channel_method</code></a></li><li><a href="#Main.IonChannel.detect_breaks_mdl"><code>Main.IonChannel.detect_breaks_mdl</code></a></li><li><a href="#Main.IonChannel.detect_double_breakpoint"><code>Main.IonChannel.detect_double_breakpoint</code></a></li><li><a href="#Main.IonChannel.detect_single_breakpoint"><code>Main.IonChannel.detect_single_breakpoint</code></a></li><li><a href="#Main.IonChannel.deviation_from_mean_method-Tuple{Vector{Float32}, Float32, MeanDeviationMethod}"><code>Main.IonChannel.deviation_from_mean_method</code></a></li><li><a href="#Main.IonChannel.dicts_to_dataframes-Tuple{Dict{String, Dict{String, Vector{Float32}}}, Dict{String, Float32}, Dict{String, Float32}}"><code>Main.IonChannel.dicts_to_dataframes</code></a></li><li><a href="#Main.IonChannel.get_specified_datapoints"><code>Main.IonChannel.get_specified_datapoints</code></a></li><li><a href="#Main.IonChannel.get_threshold_width-Tuple{HistPeakAnalysis, Float32}"><code>Main.IonChannel.get_threshold_width</code></a></li><li><a href="#Main.IonChannel.histogram_calculator"><code>Main.IonChannel.histogram_calculator</code></a></li><li><a href="#Main.IonChannel.idealize_data-Tuple{Vector{Float32}, Vector{Float32}, HistPeakAnalysis, Float32}"><code>Main.IonChannel.idealize_data</code></a></li><li><a href="#Main.IonChannel.line-Tuple{Point, Point}"><code>Main.IonChannel.line</code></a></li><li><a href="#Main.IonChannel.mdl_method-Tuple{Vector{Float32}, Float32, MDLMethod}"><code>Main.IonChannel.mdl_method</code></a></li><li><a href="#Main.IonChannel.mean_error"><code>Main.IonChannel.mean_error</code></a></li><li><a href="#Main.IonChannel.method_function-Tuple{MikaMethod}"><code>Main.IonChannel.method_function</code></a></li><li><a href="#Main.IonChannel.method_function-Tuple{DeepChannelMethod}"><code>Main.IonChannel.method_function</code></a></li><li><a href="#Main.IonChannel.method_function-Tuple{NaiveMethod}"><code>Main.IonChannel.method_function</code></a></li><li><a href="#Main.IonChannel.method_function-Tuple{MeanDeviationMethod}"><code>Main.IonChannel.method_function</code></a></li><li><a href="#Main.IonChannel.method_function-Tuple{MDLMethod}"><code>Main.IonChannel.method_function</code></a></li><li><a href="#Main.IonChannel.mika_method-Tuple{Vector{Float32}, Float32, MikaMethod}"><code>Main.IonChannel.mika_method</code></a></li><li><a href="#Main.IonChannel.naive_method-Tuple{Vector{Float32}, Float32, NaiveMethod}"><code>Main.IonChannel.naive_method</code></a></li><li><a href="#Main.IonChannel.noise-Tuple{Vector{Float32}, Vector{Float32}}"><code>Main.IonChannel.noise</code></a></li><li><a href="#Main.IonChannel.noise_data-Tuple{Noise}"><code>Main.IonChannel.noise_data</code></a></li><li><a href="#Main.IonChannel.noise_test-Tuple{Noise}"><code>Main.IonChannel.noise_test</code></a></li><li><a href="#Main.IonChannel.normalize_data-Tuple{Dict{String, Vector{Float32}}}"><code>Main.IonChannel.normalize_data</code></a></li><li><a href="#Main.IonChannel.plot_idealization_representation-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}"><code>Main.IonChannel.plot_idealization_representation</code></a></li><li><a href="#Main.IonChannel.point-Tuple{HistPeakAnalysis, Symbol, Symbol}"><code>Main.IonChannel.point</code></a></li><li><a href="#Main.IonChannel.read_all_file_paths-Tuple{String}"><code>Main.IonChannel.read_all_file_paths</code></a></li><li><a href="#Main.IonChannel.read_data-Tuple{String, String}"><code>Main.IonChannel.read_data</code></a></li><li><a href="#Main.IonChannel.show_approx_on_plot-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}"><code>Main.IonChannel.show_approx_on_plot</code></a></li><li><a href="#Main.IonChannel.show_threshold_on_plot-Tuple{StatsBase.Histogram, HistPeakAnalysis, MikaMethodOutput}"><code>Main.IonChannel.show_threshold_on_plot</code></a></li><li><a href="#Main.IonChannel.stepstat_mdl"><code>Main.IonChannel.stepstat_mdl</code></a></li><li><a href="#Main.IonChannel.δ-Tuple{MeanDeviationMethod}"><code>Main.IonChannel.δ</code></a></li><li><a href="#Main.IonChannel.λ-Tuple{MeanDeviationMethod}"><code>Main.IonChannel.λ</code></a></li><li><a href="#Main.IonChannel.μ-Tuple{Noise}"><code>Main.IonChannel.μ</code></a></li><li><a href="#Main.IonChannel.σ-Tuple{Noise}"><code>Main.IonChannel.σ</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 26 August 2025 15:41">Tuesday 26 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
