var documenterSearchIndex = {"docs":
[{"location":"#IonChannel.jl-Documentation","page":"IonChannel.jl Documentation","title":"IonChannel.jl Documentation","text":"","category":"section"},{"location":"#IonChannel","page":"IonChannel.jl Documentation","title":"IonChannel","text":"","category":"section"},{"location":"#IonChannel","page":"IonChannel.jl Documentation","title":"IonChannel","text":"module IonChannel\n\nA Julia module for advanced idealization and analysis of ion channel single-molecule data.\n\nOverview\n\nIonChannel provides type-safe, highly modular tools for the idealization, segmentation, and analysis of ion channel current traces. It implements and integrates methods based on running-mean deviation, histogram-based segmentation, threshold optimization, MDL change-point detection, and deep-learning-based state detection, supporting workflows in quantitative biophysics and single-molecule electrophysiology.\n\nMain Features\n\nIdealization Methods:\nAbstract parameter types (IdealizationMethod) and result types (MethodOutput) for extensible algorithms.\nImplementations: deviation-from-mean (MeanDeviationMethod), Mika method (MikaMethod), Naive histogram thresholding (NaiveMethod), MDL segmentation (MDLMethod), and DeepChannel (Python model via PyCall, DeepChannelMethod).\nData Handling:\nRead paired raw traces and dwell times from files: read_data, or enumerate dataset folders with read_all_file_paths.\nExtract subsets, align dwell windows, and normalize signals: get_specified_datapoints, normalize_data, combine_time_with_data.\nHistogram Analysis:\nBuild histograms and probability histograms: histogram_calculator, calculate_probability_histogram.\nPeak/trough and midpoint detection for bimodal signals: analyze_histogram_peaks → HistPeakAnalysis.\nNoise and Fit Evaluation:\nResidual modeling and statistics with Noise and noise_data.\nDwell-time distribution comparison via calculate_mean_square_error (returns MSE and histograms).\nEnd-to-end benchmark across datasets with mean_error (returns MeanError).\nVisualization:\nOverlay exact vs. approximated breakpoints and thresholds: show_approx_on_plot.\nStacked plots of raw vs. idealized sequences: plot_idealization_representation.\nThreshold and peaks on histogram (Mika): show_threshold_on_plot.\n\nTypical Workflow\n\nReading Data: Use read_data or read_all_file_paths to load trace data and associated dwell times.\nIdealization: Choose an idealization method struct (e.g. MeanDeviationMethod, MikaMethod, NaiveMethod, MDLMethod, DeepChannelMethod) and run the algorithm (e.g., calculate_method, mika_method, naive_method, mdl_method, deep_channel_method) to obtain a <: MethodOutput with breakpoints, dwell_times_approx, and an idealized_data sequence.\nHistogram and Threshold: Generate and analyze histograms with histogram_calculator and analyze_histogram_peaks. Convert counts to probabilities via calculate_probability_histogram.\nVisualization: Visualize results using show_approx_on_plot, show_threshold_on_plot, and plot_idealization_representation.\nNoise and Evaluation: Quantify residuals with noise_data and evaluate dwell-time fit via calculate_mean_square_error; assess full-run performance with mean_error.\n\nExtending the Module\n\nTo add a new idealization method:\n\nCreate a new parameter struct <: IdealizationMethod (store parameters only).\nImplement your algorithm my_method(data::Vector{Float32}, t::Float32, m::MyMethod) -> <: MethodOutput.\nLink your method via method_function(::MyMethod) = my_method so it works with the generic calculate_method.\n\nKey Types\n\nAbstractions: IdealizationMethod, MethodOutput\nMethods and outputs: MeanDeviationMethod, MeanDeviationMethodOutput; MikaMethod, MikaMethodOutput; NaiveMethod, NaiveMethodOutput; MDLMethod, MDLMethodOutput; DeepChannelMethod, DeepChannelMethodOutput\nAnalysis helpers: HistPeakAnalysis, ThresholdWidth, Noise, Point, Line\nEvaluation aggregates: MeanError\n\nSelected API (canonical names)\n\nData I/O and prep:\nread_data(data_file_path::String, dwell_times_path::String) -> (x::Vector{Float32}, y::Vector{Float32})\nread_all_file_paths(data_folder::String) -> (what_first_path::String, data_file_paths::Vector{String}, dwell_times_file_paths::Vector{String})\nget_specified_datapoints(x::Vector{Float32}, y::Vector{Float32}, t::Float32, data_size::UInt32=0) -> Dict(\"x\"=>..., \"dwell times\"=>...)\nnormalize_data(data::Dict{String,Vector{Float32}}) -> Vector{Float32}\ncombine_time_with_data(x::Vector{Float32}, t::Float32; batch_size::UInt8=1) -> Vector{Tuple{Float32,Float32}}\nHistogram and peaks:\nhistogram_calculator(x::Vector{Float32}, bins::UInt16=100) -> StatsBase.Histogram\ncalculate_probability_histogram(h::Histogram) -> Histogram\nanalyze_histogram_peaks(h::Histogram) -> HistPeakAnalysis\nIdealization methods:\ndeviation_from_mean_method(x::Vector{Float32}, t::Float32, m::MeanDeviationMethod) -> MeanDeviationMethodOutput\nmika_method(x::Vector{Float32}, t::Float32, m::MikaMethod) -> MikaMethodOutput\nnaive_method(x::Vector{Float32}, t::Float32, m::NaiveMethod) -> NaiveMethodOutput\nmdl_method(x::Vector{Float32}, t::Float32, m::MDLMethod) -> MDLMethodOutput\ndeep_channel_method(x::Vector{Float32}, t::Float32, m::DeepChannelMethod) -> DeepChannelMethodOutput\nmethod_function(::IdealizationMethod) → returns the concrete callable for calculate_method\ncalculate_method(x::Vector{Float32}, m::IdealizationMethod, t::Float32) -> MethodOutput\nEvaluation and reconstruction:\ncalculate_mean_square_error(data::Dict, dwell_times_approx::Vector{Float32}, dt_bins::UInt16=100) -> (mse::Float32, hist_data::Histogram, hist_approx::Histogram)\naccuracy_of_idealization(actual::Vector{UInt8}, approx::Vector{UInt8}) -> Float32\nmean_error(method::IdealizationMethod, t::Float32, data_size::UInt32, verbose::Bool=false) -> MeanError\nactual_idealize_data(data::Dict, what_first_dict::Dict{String,Int64}, file_name::AbstractString, t::Float32) -> Vector{UInt8}\nidealize_data(data::Vector{Float32}, dwell_times_approx::Vector{Float32}, hist::HistPeakAnalysis, t::Float32) -> Vector{Float32}\ncreate_idealizations(data_folder::String, t::Float32=1e-4f0) -> Dict{String,Vector{Int8}}\nMDL internals (exposed helpers):\n_mdl(segment::Vector{Float32}, BP::Vector{UInt32}) -> Float32\n_test_breakpoint(segment::Vector{Float32}, candidate::Vector{UInt32}) -> Bool\ndetect_single_breakpoint(data::Vector{Float32}, min_seg::UInt16=300) -> Vector{UInt32}\ndetect_double_breakpoint(data::Vector{Float32}, min_seg::UInt16=300) -> Vector{UInt32}\ndetect_breaks_mdl(segment::Vector{Float32}, method::AbstractString, min_seg::UInt16=300) -> Vector{UInt32}\nstepstat_mdl(data::Vector{Float32}, BP::Vector{UInt32}, threshold::Float32=0.8f0) -> (filtered::Vector{UInt32}, stepvalues::Vector{Float32})\n\nExample\n\nusing IonChannel\n\nx, y = read_data(\"trace.txt\", \"dwell.txt\")\n\nt = 1e-4f0\nxnorm = normalize_data(Dict(\"x\" => x))\nparams = MikaMethod(UInt16(120))\nresult = calculate_method(xnorm, params, t)\n\nshow_approx_on_plot(Dict(\"x\"=>x, \"dwell times\"=>y), result, 0.5f0, 0.9f0, t)\n\nAuthors\n\nCreated and maintained by Piotr Mika.\n\n\n\n\n\n","category":"module"},{"location":"#Read-Data","page":"IonChannel.jl Documentation","title":"Read Data","text":"","category":"section"},{"location":"#Main.IonChannel.combine_time_with_data","page":"IonChannel.jl Documentation","title":"Main.IonChannel.combine_time_with_data","text":"combine_time_with_data(data::Vector{Float32}, Δt::Float32, batch_size::UInt8=1) -> Vector{Tuple{Float32, Float32}}\n\nCreate a time-stamped version of raw data, pairing each value with its time in the sampled sequence.\n\nArguments\n\ndata::Vector{Float32}  \n\nThe signal or measurement data to be time-stamped.\n\nΔt::Float32  \n\nThe sampling interval (seconds) between consecutive data points.\n\nbatch_size::UInt8 (optional, default = 1)  \n\nThe step size for batch-wise processing; typically leave as 1 for full sequence.\n\nReturns\n\nVector{Tuple{Float32, Float32}}  \n\nA vector of (time, value) pairs. The time values run from 0 to the end in steps of Δt * batch_size, each paired with the matching data value.\n\nDescription\n\nPairs each data point with its corresponding timestamp, supporting batch-wise access for processing algorithms that operate on downsampled or chunked data.\n\nExample\n\ndata = [0.1, 0.2, 0.3, 0.4]\nΔt = 0.01\npairs = combine_time_with_data(data, Δt)\n\n\n\n\n\n","category":"function"},{"location":"#Main.IonChannel.get_specified_datapoints","page":"IonChannel.jl Documentation","title":"Main.IonChannel.get_specified_datapoints","text":"get_specified_datapoints(x::Vector{Float32}, y::Vector{Float32}, Δt::Float32, data_size::UInt32=0) \n    -> Dict{String, Vector{Float32}}\n\nExtract a segment of the x data vector and the corresponding dwell times segment  up to a specified number of data points or total recording time.\n\nArguments\n\nx::Vector{Float32}: Time series or measurement values.\ny::Vector{Float32}: Corresponding dwell times between events or state changes.\nΔt::Float32: Sampling interval in seconds for the x data.\ndata_size::UInt32 (optional, default=0):  \n\nNumber of samples to include in the result.  \n\nIf 0, the entire dataset is used.\nOtherwise, selects the first data_size samples of x and the dwell times covered by them.\n\nReturns\n\nDict{String, Vector{Float32}}:\n\n\"x\" → The truncated x vector containing the first data_size samples (or all samples if data_size==0).\n\"dwell times\" → A truncated version of y containing only those dwell time segments whose cumulative sum\n\ndoes not exceed max_time = data_size * Δt.\n\nMethod\n\nDetermine the number of samples to include (data_size), using the full length of x if data_size==0.\nCompute the max_time in seconds corresponding to the selected number of points.\nInclude only those dwell time segments from y whose cumulative sum is less than or equal to max_time.\nReturn both the truncated x and the matching truncated y in a dictionary.\n\nExample\n\nx, y = read_data(\"data.txt\", \"dwell_times.txt\")\ndata = get_specified_datapoints(x, y, Δt, 50)\nprintln(data[\"x\"])\nprintln(data[\"dwell times\"])\n\nNotes\n\nThe dwell times are selected based on cumulative duration, not index count.\nThis function preserves the original order of the dwell times.\nIt assumes that x and y represent compatible datasets in terms of recording sequence.\n\n\n\n\n\n","category":"function"},{"location":"#Main.IonChannel.normalize_data-Tuple{Dict{String, Vector{Float32}}}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.normalize_data","text":"normalize_data(data::Dict{String, Vector{Float32}}) -> Vector{Float32}\n\nNormalize the \"x\" values in a data dictionary to have zero mean and unit variance using z-score normalization.\n\nArguments\n\ndata::Dict{String, Vector{Float32}}:  \n\nA dictionary containing at least the key \"x\" mapped to a vector of floating-point values (such as raw measurement data).   Other keys (e.g., \"dwell times\") may be present but are ignored.\n\nReturns\n\nVector{Float32}:  \n\nA new vector of the same length as data[\"x\"], where each element has been normalized:\n\nzi = (xi - μ) / σ\n\nwhere μ is the mean of x, and σ is its standard deviation.\n\nMethod\n\nFit a [ZScore] scaling model\n\nto the \"x\" values using fit(ZScore, data[\"x\"]).\n\nApply the normalize function from StatsBase to transform the data into z-scores.\nReturn the transformed vector.\n\nExample\n\nx, y = read_data(\"data.txt\", \"dwell_times.txt\")\ndata = get_specified_datapoints(x, y, Δt, 50)\nnormalized_x = normalize_data(data)\n\nNotes\n\nRequires the StatsBase.jl and Normalization.jl package.\nThe \"x\" vector must not be empty and must contain finite real values.\nThis function does not modify the original dictionary; it returns a new normalized vector.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.read_all_file_paths-Tuple{String}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.read_all_file_paths","text":"readallfilepaths(datafolder::String) -> Tuple{String, Vector{String}, Vector{String}}\n\nCollect and return file paths for experimental data files and their corresponding dwell time files from a structured folder hierarchy.\n\nArguments\n\ndata_folder::String: The path (relative or absolute) to the main data folder.  \n\nThe expected directory structure inside data_folder is:\n\ndatafolder/     sampling/         <voltage1>/             file1.txt             file2.txt             ...         <voltage2>/             ...     dwelltimes/         <voltage1>/             file1dwelltimesy.txt             ...         <voltage2>/             ...\n\nReturns\n\nA tuple:\n\nwhat_first_path::String — Path to the first special file found at the top level of data_folder\n\n(taken from the 3rd entry in its directory listing).\n\ndata_file_paths::Vector{String} — Full paths to all sampled data files across all voltages.\ndwell_times_file_paths::Vector{String} — Full paths to the corresponding dwell time files,\n\nin the same order as data_file_paths.\n\nFile matching logic\n\nData files are taken from /sampling/<voltage>/, selecting every second file starting at index 2.\nDwell time files are taken from /dwell_times/<voltage>/, selecting every second file starting at index 1.\nThe dwell time file names are derived from the data file names by replacing the base name\n\nwith <basename>dwell_timesy and preserving the original extension.\n\nExample\n\nwhat_first, data_paths, dwell_paths = read_all_file_paths(\"experiment_data\")\nprintln(\"First reference file: \", what_first)\nprintln(\"Number of data files: \", length(data_paths))\nprintln(\"Number of dwell time files: \", length(dwell_paths))\n\nNotes\n\nAssumes a specific directory and file naming convention.\nFile order consistency is crucial for correctly matching data with dwell times.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.read_data-Tuple{String, String}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.read_data","text":"readdata(datafilepath::String, dwelltimes_path::String) -> Tuple{Vector{Float32}, Vector{Float32}}\n\nRead numerical data from two text files and return them as vectors of Float32.\n\nArguments\n\ndata_file_path::String: Path to a text file containing numerical values (one per line)\n\nrepresenting the primary data set.\n\ndwell_times_path::String: Path to a text file containing numerical values (one per line)\n\ncorresponding to dwell times.\n\nReturns\n\nA tuple (x, y) where:\n\nx::Vector{Float32}: Values read from the first file.\ny::Vector{Float32}: Values read from the second file.\n\nExample\n\nx, y = read_data(\"data.txt\", \"dwell_times.txt\")\n\nBoth files must contain one floating-point number per line, with optional whitespace.\n\n\n\n\n\n","category":"method"},{"location":"#Types","page":"IonChannel.jl Documentation","title":"Types","text":"","category":"section"},{"location":"#Main.IonChannel.DeepChannelMethod","page":"IonChannel.jl Documentation","title":"Main.IonChannel.DeepChannelMethod","text":"DeepChannelMethod <: IdealizationMethod\n\nWrapper for a Python-based deep learning model used to idealize ion-channel time-series data into discrete states.\n\nThis type stores a reference to a Python model (e.g., a Keras/PyTorch model accessed via PyCall.PyObject) that supports per-sample classification (prediction) over the input trace after appropriate preprocessing.\n\nFields\n\nmodel::PyObject: The underlying Python model object. It is expected to expose a prediction API compatible with the calling code (e.g., a .predict method that accepts a 4D tensor shaped like (N, 1, 1, 1) and returns class probabilities per sample).\n\nUsage\n\nTypically passed into deep_channel_method(data, Δt, c_method) to produce:\nper-sample predicted class labels,\ntransition breakpoints,\napproximate dwell times.\n\nNotes\n\nEnsure PyCall is properly initialized and the Python environment includes all dependencies required by the model (e.g., TensorFlow/Keras or PyTorch).\nInput preprocessing (e.g., scaling with UnitRangeTransform and reshaping to (N,1,1,1)) is handled by deep_channel_method.\nThe model is expected to output a probability distribution over states for each sample; downstream code uses argmax to select the most likely class.\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.DeepChannelMethodOutput","page":"IonChannel.jl Documentation","title":"Main.IonChannel.DeepChannelMethodOutput","text":"DeepChannelMethodOutput <: MethodOutput\n\nContainer for the outputs of the deep learning–based idealization (DeepChannel method).\n\nHolds the approximate dwell times, transition times (breakpoints), and the full per-sample idealized state sequence.\n\nFields\n\ndwell_times_approx::Vector{Float32}: Approximate durations spent in each detected state segment, typically computed from successive transition times.\nbreakpoints::Vector{Float32}: Transition times (relative to the start of the trace) at which the state changes.\nidealized_data::Vector{UInt8}: Per-sample predicted states (e.g., 0/1) produced by the model after preprocessing and decoding.\n\nNotes\n\nUnits of dwell_times_approx and breakpoints depend on the sampling interval used upstream (e.g., Δt in seconds or milliseconds).\nidealized_data provides the full-resolution state assignment, while dwell_times_approx and breakpoints summarize state changes.\nDesigned to be returned by deep_channel_method.\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.HistPeakAnalysis","page":"IonChannel.jl Documentation","title":"Main.IonChannel.HistPeakAnalysis","text":"HistPeakAnalysis\n\nStructure holding the results of peak and trough analysis on a histogram.\n\nFields\n\nedges::Vector{Float32}  \n\nThe bin edges of the histogram.\n\nweights::Vector{Float32}  \n\nThe counts or weights for each histogram bin.\n\npmax1::Float32  \n\nThe height (weight) of the first (primary) maximum peak.\n\npmax1_index::Int  \n\nThe bin index of the first maximum peak.\n\npmax2::Float32  \n\nThe height (weight) of the second maximum peak.\n\npmax2_index::Int  \n\nThe bin index of the second maximum peak.\n\nmidpoint::Int  \n\nThe index representing the midpoint between the two main peaks.\n\npmin::Float32  \n\nThe height (weight) of the minimum (trough) between the two main peaks.\n\npmin_index::Int  \n\nThe bin index of the minimum (trough) between the two main peaks.\n\nDescription\n\nHistPeakAnalysis encapsulates detailed information about the histogram peaks and troughs necessary for further analysis such as threshold determination.\n\nIt is typically produced by the function analyze_histogram_peaks.\n\nExample\n\nhist_analysis = analyze_histogram_peaks(prob_hist)\nprintln(\"Primary peak at bin \", hist_analysis.pmax1_index, \" with weight \", hist_analysis.pmax1)\nprintln(\"Minimum between peaks at bin \", hist_analysis.pmin_index)\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.IdealizationMethod","page":"IonChannel.jl Documentation","title":"Main.IonChannel.IdealizationMethod","text":"IdealizationMethod\n\nAbstract supertype for all idealization method parameter types.\n\nEach concrete subtype of IdealizationMethod stores only the parameters specific to that method. The associated computation algorithm is defined separately and linked to the subtype via a method(::YourMethodType) function.\n\nUsage\n\nTo implement a new method:\n\nCreate a new struct subtype of IdealizationMethod that stores parameters.\nWrite the algorithm function:\nmy_algorithm(data::Vector{Float32}, Δt::Float32, m::MyMethodType) -> Vector{Float32}\nLink it to the type with:\nmethod(::MyMethodType) = my_algorithm\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.Line","page":"IonChannel.jl Documentation","title":"Main.IonChannel.Line","text":"Line\n\nRepresents a 2D line defined by the equation y = a * x + b.\n\nFields\n\na::Float32 — The slope of the line.\nb::Float32 — The y-intercept of the line.\n\nExample\n\nline = Line(2.0, 1.0) # y = 2x + 1\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.MDLMethod","page":"IonChannel.jl Documentation","title":"Main.IonChannel.MDLMethod","text":"MDLMethod <: IdealizationMethod\n\nConfiguration for an idealization approach based on the Minimum Description Length (MDL) principle.\n\nThe MDL method selects a piecewise-constant segmentation of the signal that minimizes the total description length (model complexity + data fit). It balances the number of segments (penalizing over-segmentation) against how well segments explain the data.\n\nFields\n\nmin_seg::UInt16: Minimum allowed segment length (in samples). Prevents overly short segments that are likely due to noise.\nthreshold::Float32: Amplitude or penalty threshold used within the MDL search/criteria. Its interpretation depends on the specific implementation (e.g., penalty weight, merge/split decision threshold).\nnumber_of_histogram_bins::UInt16: Number of bins for any histogram-based auxiliary steps (e.g., estimating noise statistics or amplitude modes) used by the MDL routine.\n\nUsage\n\nConstruct and pass to an MDL-based idealization function, e.g.: mdl_method(data, Δt, method::MDLMethod) -> MDLMethodOutput (function and output type names may vary based on your implementation).\n\nNotes\n\nThe MDL criterion typically trades off data fidelity and model complexity; tuning min_seg and threshold impacts the balance between false positives (spurious segments) and missed transitions.\nWorks well when the signal is piecewise constant with sparse change points and approximately stationary noise.\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.MDLMethodOutput","page":"IonChannel.jl Documentation","title":"Main.IonChannel.MDLMethodOutput","text":"MDLMethodOutput <: MethodOutput\n\nContainer for the results of an MDL-based idealization.\n\nHolds the detected change-point times (breakpoints), the corresponding approximate dwell durations, and the full per-sample idealized state sequence.\n\nFields\n\nbreakpoints::Vector{Float32}: Times (relative to the start of the trace) at which the signal is estimated to change state according to the MDL segmentation.\ndwell_times_approx::Vector{Float32}: Approximate durations spent in each state segment, typically computed from successive breakpoints (the first dwell time usually equals the first breakpoint time).\nidealized_data::Vector{UInt8}: Per-sample state assignments (e.g., 0/1) produced by the MDL idealization over the entire trace length.\n\nNotes\n\nUnits of breakpoints and dwell_times_approx depend on the sampling interval used upstream (e.g., Δt in seconds or milliseconds).\nidealized_data provides the full-resolution labeling, while breakpoints and dwell_times_approx summarize the segmentation.\nDesigned to be returned by an MDL idealization routine (e.g., mdl_method).\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.MeanDeviationMethod","page":"IonChannel.jl Documentation","title":"Main.IonChannel.MeanDeviationMethod","text":"MeanDeviationMethod <: IdealizationMethod\n\nParameters for the deviation-from-running-mean idealization method.\n\nFields\n\nδ::Float32 - Deviation offset subtracted from the absolute deviation before thresholding.\nλ::Float32 - Threshold value above which a deviation from the mean indicates a state change.\n\nDescription\n\nMeanDeviationMethod stores only these two numeric parameters. The actual algorithm is implemented in deviation_from_mean_method and linked via:\n\nmethod(::MeanDeviationMethod) = deviation_from_mean_method\n\nExample\n\n\nprintln(method_function(m)) # shows the stored function\nprintln(δ(m)) # 0.05\nprintln(λ(m)) # 0.5\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.MeanDeviationMethodOutput","page":"IonChannel.jl Documentation","title":"Main.IonChannel.MeanDeviationMethodOutput","text":"MeanDeviationMethodOutput <: MethodOutput\n\nType describing the output of the mean deviation idealization method.\n\nFields\n\nbreakpoints::Vector{Float32}   The cumulative breakpoints (timepoints, in seconds) at which state changes occur in the idealized trace, as computed by the method.\ndwell_times_approx::Vector{Float32}   The sequence of estimated dwell times between state transitions (in seconds) produced by the algorithm.\n\nDescription\n\nThis struct bundles the main outputs from the mean deviation idealization routine. It allows downstream analysis, comparison, or visualization of both raw and processed results.\n\nTypically constructed and returned by deviation_from_mean_method or generic idealization runners.\n\nExample\n\nresult = deviation_from_mean_method(normalized_data, Δt, MeanDeviationMethod(δ, λ))\nresult.breakpoints # Vector of breakpoints (seconds)\nresult.dwell_times_approx # Vector of dwell times (seconds)\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.MeanError","page":"IonChannel.jl Documentation","title":"Main.IonChannel.MeanError","text":"MeanError\n\nAggregate metrics for evaluating idealization or prediction performance across multiple segments, traces, or runs.\n\nFields\n\nmean_squared_error::Float32: The overall mean of squared errors, typically averaged across all samples and/or batches.\nmean_accuracy::Float32: The overall accuracy aggregated across evaluations, commonly expressed as a fraction in [0.0, 1.0].\nmean_squared_errors::Vector{Float32}: Per-segment or per-batch MSE values used to compute mean_squared_error.\naccuracies::Vector{Float32}: Per-segment or per-batch accuracy values used to compute mean_accuracy.\n\nNotes\n\nThis struct is a convenient container when running repeated evaluations (e.g., cross-validation folds, multiple traces, or bootstrapped subsets).\nmean_squared_error is typically computed from mean(mean_squared_errors), and mean_accuracy from mean(accuracies), but storing all components keeps downstream analysis flexible (e.g., computing variance or confidence intervals).\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.MethodOutput","page":"IonChannel.jl Documentation","title":"Main.IonChannel.MethodOutput","text":"MethodOutput\n\nAbstract supertype for all output types produced by idealization methods in IonChannel.\n\nAll result types describing the outcome of an idealization algorithm—such as dwell times, breakpoints, noise metrics, and other analysis products—should subtype this.\n\nThis enables consistent downstream handling, generic dispatch, and unified documentation for results from different algorithms.\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.MikaMethod","page":"IonChannel.jl Documentation","title":"Main.IonChannel.MikaMethod","text":"MikaMethod <: IdealizationMethod\n\nParameters and a method function for the Mika idealization method.\n\nFields\n\nnumber_of_histogram_bins::UInt16  \n\nThe number of bins used in histogram computations during idealization.\n\nDescription\n\nMikaMethod stores parameters essential for controlling the thresholding and histogram binning in the Mika method. The associated algorithm is linked via method_function(::MikaMethod).\n\nExample\n\nm = MikaMethod(100)\nresult = calculate_method(data, m, Δt)\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.MikaMethodOutput","page":"IonChannel.jl Documentation","title":"Main.IonChannel.MikaMethodOutput","text":"MikaMethodOutput <: MethodOutput\n\nStructure holding the results of the Mika idealization method.\n\nFields\n\nbreakpoints::Vector{Float32}  \n\nVector of cumulative breakpoint times (in seconds) indicating detected state changes.\n\ndwell_times_approx::Vector{Float32}  \n\nEstimated dwell times (in seconds) between detected transitions.\n\nidealized_data::Vector{Float32}  \n\nThe reconstructed idealized signal corresponding to the original data.\n\nnoise::Noise  \n\nA Noise struct capturing residuals between the original and idealized data and associated statistics.\n\nthreshold::ThresholdWidth  \n\nThe threshold and its bounds used for state transition detection.\n\nnoise_mse::Float32  \n\nThe mean squared error between the noise and its fitted normal distribution.\n\nDescription\n\nMikaMethodOutput bundles all significant outputs of the Mika idealization procedure, enabling comprehensive downstream analysis and visualization.\n\nAccessor Functions\n\nEach field has a corresponding accessor function for convenient retrieval:\n\nbreakpoints(optimized_data::MikaMethodOutput)  \ndwell_times_approx(optimized_data::MikaMethodOutput)  \nidealized_data(optimized_data::MikaMethodOutput)  \nnoise(optimized_data::MikaMethodOutput)  \nthreshold(optimized_data::MikaMethodOutput)  \nnoise_mse(optimized_data::MikaMethodOutput)  \n\nThese allow accessing parts of the output without field syntax.\n\nExample\n\nresult = mika_method(data, Δt, MikaMethod(120))\n\nprintln(\"Threshold used: \", threshold(result))\nprintln(\"Number of breakpoints detected: \", length(breakpoints(result)))\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.NaiveMethod","page":"IonChannel.jl Documentation","title":"Main.IonChannel.NaiveMethod","text":"NaiveMethod <: IdealizationMethod\n\nConfiguration for a simple histogram-threshold-based idealization method.\n\nThis method estimates a decision threshold from the empirical distribution of signal amplitudes (via histogram analysis) and detects state transitions when the signal crosses that threshold.\n\nFields\n\nnumber_of_histogram_bins::UInt16: Number of bins to use when building the amplitude histogram. A larger value can capture finer structure but may be noisier; typical ranges are 50-200 depending on data length and noise.\n\nUsage\n\nPass an instance to naive_method(data, Δt, method) to produce:\ntransition breakpoints,\ndwell_times,\nper-sample binary idealized_data (0/1).\n\nNotes\n\nThe chosen bin count influences the stability of the estimated threshold.\nWorks best for bimodal amplitude distributions with reasonably separated modes.\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.NaiveMethodOutput","page":"IonChannel.jl Documentation","title":"Main.IonChannel.NaiveMethodOutput","text":"NaiveMethodOutput <: MethodOutput\n\nContainer for outputs produced by the histogram-threshold-based idealization pipeline (naive_method).\n\nFields\n\ndwell_times_approx::Vector{Float32}: Approximate durations spent in each state segment, typically computed from differences between successive breakpoints (first element usually equals the first breakpoint time).\nbreakpoints::Vector{Float32}: Transition times (relative to the start of the trace) at which the signal crosses the estimated threshold and the state flips.\nidealized_data::Vector{UInt8}: Per-sample binary state assignments (0 or 1) derived by tracking threshold crossings over the time series.\n\nNotes\n\nUnits of dwell_times_approx and breakpoints are determined by the sampling interval used upstream (e.g., Δt).\nidealized_data provides the full-length state sequence, while dwell_times_approx and breakpoints summarize state changes.\nDesigned to be returned by naive_method.\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.Noise","page":"IonChannel.jl Documentation","title":"Main.IonChannel.Noise","text":"Noise\n\nMutable structure holding noise characteristics computed as differences between raw data and idealized values.\n\nFields\n\nξ::Vector{Float32}  \n\nThe vector of residuals (noise), computed as data - idealized_values.\n\nμ::Float32  \n\nThe mean of the noise vector.\n\nσ::Float32  \n\nThe standard deviation of the noise vector.\n\nDescription\n\nNoise encapsulates statistical information about deviation of the observed data from an idealized signal, useful for assessing fit quality and noise properties.\n\n\n\nnoise_data(noise::Noise) -> Vector{Float32}   Accessor function returning the raw noise vector ξ.\n\nμ(noise::Noise) -> Float32   Accessor function returning the mean of the noise.\n\nσ(noise::Noise) -> Float32   Accessor function returning the standard deviation of the noise.\n\n\n\nnoise(data::Vector{Float32}, idealized_values::Vector{Float32}) -> Noise   Computes and returns a Noise object representing the noise between raw data and idealized values.\n\nArguments\n\ndata::Vector{Float32}  \n\nThe original data vector.\n\nidealized_values::Vector{Float32}  \n\nThe idealized or reconstructed data vector.\n\nReturns\n\nNoise  \n\nA Noise struct containing the residual vector and its statistical properties.\n\nExample\n\ndata = [1.0, 2.1, 2.9, 4.1]\nidealized = [1.0, 2.0, 3.0, 4.0]\nn = noise(data, idealized)\nprintln(\"Noise mean: \", μ(n))\nprintln(\"Noise std dev: \", σ(n))\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.Point","page":"IonChannel.jl Documentation","title":"Main.IonChannel.Point","text":"Point\n\nA simple 2D point with x and y coordinates.\n\nFields\n\nx::Float32 — The horizontal coordinate.\ny::Float32 — The vertical coordinate.\n\nExample\n\np = Point(1.0, 2.0)\nprintln(p.x) # 1.0\nprintln(p.y) # 2.0\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.ThresholdWidth","page":"IonChannel.jl Documentation","title":"Main.IonChannel.ThresholdWidth","text":"ThresholdWidth\n\nStructure representing the threshold range for an idealization method.\n\nFields\n\nthreshold_centre::Float32  \n\nThe central threshold value used for detecting state transitions.\n\nx₁::Float32  \n\nThe lower bound of the threshold band.\n\nx₂::Float32  \n\nThe upper bound of the threshold band.\n\nDescription\n\nThresholdWidth encapsulates the main threshold and its bounds within which the signal values are considered for state transition analysis.\n\nIt is typically computed during histogram-based threshold optimization and used for breakpoint detection.\n\nExample\n\nthr_width = ThresholdWidth(0.5, 0.3, 0.7)\nprintln(\"Center threshold: \", thr_width.threshold_centre)\nprintln(\"Lower bound: \", thr_width.x₁)\nprintln(\"Upper bound: \", thr_width.x₂)\n\n\n\n\n\n","category":"type"},{"location":"#Main.IonChannel.noise-Tuple{Vector{Float32}, Vector{Float32}}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.noise","text":"Computes and returns a Noise object representing the noise between raw data and idealized values. See more in the Noise struct documentation.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.noise_data-Tuple{Noise}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.noise_data","text":"noise_data(noise::Noise) -> Vector{Float32}\n\nAccessor function returning the raw noise vector ξ.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.δ-Tuple{MeanDeviationMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.δ","text":"δ(m::MeanDeviationMethod) -> Float32\n\nReturn the δ (delta) parameter from the given MeanDeviationMethod instance.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.λ-Tuple{MeanDeviationMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.λ","text":"λ(m::MeanDeviationMethod) -> Float32\n\nReturn the λ (lambda) parameter from the given MeanDeviationMethod instance.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.μ-Tuple{Noise}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.μ","text":"μ(noise::Noise) -> Float32\n\nAccessor function returning the mean of the noise.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.σ-Tuple{Noise}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.σ","text":"σ(noise::Noise) -> Float32\n\nAccessor function returning the standard deviation of the noise.\n\n\n\n\n\n","category":"method"},{"location":"#Methods-of-idealization","page":"IonChannel.jl Documentation","title":"Methods of idealization","text":"","category":"section"},{"location":"#Naive-Method","page":"IonChannel.jl Documentation","title":"Naive Method","text":"","category":"section"},{"location":"#Main.IonChannel.method_function-Tuple{NaiveMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.method_function","text":"method_function(::NaiveMethod) -> Function\n\nReturn the algorithm function associated with a NaiveMethod.\n\nThis allows code like calculate_method(data, m, Δt) to work for any IdealizationMethod subtype without changing the executor logic.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.naive_method-Tuple{Vector{Float32}, Float32, NaiveMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.naive_method","text":"naive_method(\n    data::Vector{Float32},\n    Δt::Float32,\n    method::NaiveMethod\n) :: NaiveMethodOutput\n\nPerform a simple threshold-based idealization of a time-series by detecting crossings between two histogram-derived peaks.\n\nThis method:\n\nbuilds a histogram of the signal,\nconverts it to a probability histogram,\nanalyzes peak structure to estimate a threshold between two modes,\ndetects state transitions (0 ↔ 1) when the signal crosses that threshold,\nreturns breakpoints, dwell times, and the binary idealized state sequence.\n\nArguments\n\ndata::Vector{Float32}: The raw time-series trace to be idealized.\nΔt::Float32: Sampling interval used to assign times to samples and compute dwell durations.\nmethod::NaiveMethod: Configuration object that must provide number_of_histogram_bins and supports the auxiliary functions used here (see Notes).\n\nReturns\n\nNaiveMethodOutput: A struct with fields:\nbreakpoints::Vector{Float32}: Times at which state transitions occur.\ndwell_times::Vector{Float32}: Durations between successive breakpoints (first dwell time is breakpoints[1]).\nidealized_data::Vector{Int}: Binary sequence of states per sample (0 or 1).\n\nMethod\n\nCompute histogram and probability histogram:\nhistogram_of_data = histogram_calculator(data, method.number_of_histogram_bins)\nprob_hist = calculate_probability_histogram(histogram_of_data)\nEstimate threshold from histogram peak analysis:\nhist_analysis = analyze_histogram_peaks(prob_hist)\nthreshold = hist_analysis.edges[hist_analysis.pmin_index]\nCombine times with data:\ndata_with_times = combine_time_with_data(data, Δt) (expected shape Nx2, columns: time, value)\nInitialize state from first sample relative to threshold.\nIterate through samples:\nDetect upward crossings (0→1) when previous < threshold and current > threshold.\nDetect downward crossings (1→0) when previous > threshold and current < threshold.\nRecord transition times in breakpoints and append current_state to idealized_data.\nCompute dwell times:\ndwell_times = append!([breakpoints[1]], diff(breakpoints))\nReturn NaiveMethodOutput(breakpoints, dwell_times, idealized_data).\n\nNotes\n\nThe following helper functions are expected to be available in scope:\nhistogram_calculator(data::AbstractVector, nbins::Integer)\ncalculate_probability_histogram(histogram)\nanalyze_histogram_peaks(prob_hist) returning at least edges and pmin_index\ncombine_time_with_data(data, Δt) returning a 2-column array [time value]\nState labeling convention: below threshold → 0, above threshold → 1.\nidealized_data is constructed sample-by-sample; breakpoints are continuous-time instants.\nThe code assumes at least one crossing; if breakpoints is empty, computing dwell_times as written will error. Consider guarding this case in production.\n\nExample\n\ntrace = rand(Float32, 10_000)\nΔt = 1f-4\nmethod = NaiveMethod(number_of_histogram_bins = 100)\n\nresult = naive_method(trace, Δt, method)\n\nprintln(\"Breakpoints: \", result.breakpoints)\nprintln(\"Dwell times: \", result.dwell_times)\nprintln(\"First 20 states: \", result.idealized_data[1:20])\n\n\n\n\n\n","category":"method"},{"location":"#Mean-Deviation-Method","page":"IonChannel.jl Documentation","title":"Mean Deviation Method","text":"","category":"section"},{"location":"#Main.IonChannel.deviation_from_mean_method-Tuple{Vector{Float32}, Float32, MeanDeviationMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.deviation_from_mean_method","text":"deviation_from_mean_method(data::Vector{Float32}, Δt::Float32, c_method::MeanDeviationMethod) -> Vector{Float32}\n\nEstimate dwell times by detecting deviations from a running mean.\n\nArguments\n\ndata::Vector{Float32} - The (usually normalized) signal to analyse.\nΔt::Float32 - Sampling interval in seconds.\nm::MeanDeviationMethod - Parameters container; provides m.δ and m.λ.\n\nReturns\n\nVector{Float32} - Estimated dwell times in seconds.\n\nAlgorithm\n\nStart with the first value as the mean.\nFor each new sample:\n\nIf not in \"different state\" mode, update the running mean.\nCompute abs(sample - mean) - m.δ.\nIf above m.λ, trigger a state change and record dwell segment length.\nOtherwise, continue counting the current dwell segment.\n\nReturn the list of dwell segment durations.\n\nExample\n\nsignal = [0.0, 0.1, 0.2, 1.5, 1.6, 1.7, 0.2, 0.1, 0.05]\n\nm = MeanDeviationMethod(0.05, 0.5)\n\nΔt = 0.1 # 100 ms sampling interval\n\ndwell_times_est = deviation_from_mean_method(signal, Δt, m)\n\nprintln(dwell_times_est) # e.g., [0.3, 0.3, 0.3]\n\nNotes\n\nProduces only complete dwell segments; last partial segment is not appended.\nWorks best on normalized or detrended signals to remove baseline drift.\nδ(c_method) suppresses detection of very small fluctuations.\nλ(c_method) controls the sensitivity: smaller values detect more frequent changes.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.method_function-Tuple{MeanDeviationMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.method_function","text":"method_function(::MeanDeviationMethod) -> Function\n\nReturn the algorithm function associated with a MeanDeviationMethod.\n\nThis allows code like calculate_method(data, m, Δt) to work for any IdealizationMethod subtype without changing the executor logic.\n\n\n\n\n\n","category":"method"},{"location":"#Mika-Method","page":"IonChannel.jl Documentation","title":"Mika Method","text":"","category":"section"},{"location":"#Main.IonChannel.calculate_approximation-Tuple{Vector{Tuple{Float32, Float32}}, ThresholdWidth}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.calculate_approximation","text":"calculate_approximation(data_with_times::Vector{Tuple{Float32, Float32}}, threshold::ThresholdWidth) \n    -> Tuple{Vector{Float32}, Vector{Float32}}\n\nEstimate breakpoints and dwell times in a time-stamped signal using a threshold band.\n\nArguments\n\ndata_with_times::Vector{Tuple{Float32, Float32}}  \n\nVector of (time, value) pairs for the signal, e.g. output from combine_time_with_data.\n\nthreshold::ThresholdWidth  \n\nThreshold band object defining the central threshold and its lower/upper bounds.\n\nReturns\n\nTuple{Vector{Float32}, Vector{Float32}}  \n\nA tuple containing:     1. breakpoints::Vector{Float32} — estimated transition times (seconds)     2. dwell_times::Vector{Float32} — computed dwell times (seconds) between transitions\n\nDescription\n\nThis algorithm tracks signal transitions using a threshold band, finding:\n\nIntervals where the signal is within the threshold band\nMedian times of such intervals are treated as breakpoints\nDwell times are computed as time differences between breakpoints\n\nThe method handles both edge and intermediate threshold crossing logic, smoothing via medians if needed, and properly catching transitions even when noise fluctuates.\n\nExample\n\npairs = combine_time_with_data(data, Δt)\nthr_band = get_threshold_width(hist_analysis, ϵ)\nbreaks, dwell_times = calculate_approximation(pairs, thr_band)\nprintln(\"First dwell time: \", dwell_times)\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.get_threshold_width-Tuple{HistPeakAnalysis, Float32}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.get_threshold_width","text":"get_threshold_width(hist_analysis::HistPeakAnalysis, ϵ::Float32) -> ThresholdWidth\n\nCompute the threshold band used for state discrimination in idealization, based on histogram analysis and a weighting parameter.\n\nArguments\n\nhist_analysis::HistPeakAnalysis  \n\nResult of peak analysis on a histogram, containing peak and minimum bin indices and values.\n\nϵ::Float32  \n\nWeighting parameter that adjusts the positions of threshold bounds between minimum and peak values.\n\nReturns\n\nThresholdWidth  \n\nStructure detailing the central threshold and its lower (x₁) and upper (x₂) bounds.\n\nDescription\n\nCalculates a threshold band (region between two values) by linearly interpolating between the minimum and each peak, weighted by ϵ. This band is used to classify points in the signal for idealization methods.\n\nExample\n\nthr_width = get_threshold_width(hist_analysis, 0.1)\nprintln(\"Threshold center: \", thr_width.threshold_centre)\nprintln(\"Lower bound: \", thr_width.x₁)\nprintln(\"Upper bound: \", thr_width.x₂)\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.line-Tuple{Point, Point}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.line","text":"line(point1::Point, point2::Point) -> Line\n\nConstruct a Line (y = a*x + b) passing through two points.\n\nArguments\n\npoint1::Point  \n\nThe first point (x₁, y₁) through which the line will pass.\n\npoint2::Point  \n\nThe second point (x₂, y₂) through which the line will pass.\n\nReturns\n\nLine  \n\nA line in slope-intercept form (y = a*x + b), where a is the slope and b is the intercept.\n\nDescription\n\nComputes the slope (a) and y-intercept (b) for the line passing through two supplied points.\n\nExample\n\np1 = Point(1.0, 2.0)\np2 = Point(3.0, 5.0)\nl = line(p1, p2)\nprintln(\"y = $(l.a)x + $(l.b)\")\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.method_function-Tuple{MikaMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.method_function","text":"method_function(::MikaMethod) -> Function\n\nReturn the algorithm function associated with a MikaMethod.\n\nThis allows code like calculate_method(data, m, Δt) to work for any IdealizationMethod subtype without changing the executor logic.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.mika_method-Tuple{Vector{Float32}, Float32, MikaMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.mika_method","text":"mika_method(data::Vector{Float32}, Δt::Float32, method::MikaMethod) -> MikaMethodOutput\n\nApply the Mika idealization algorithm to a signal, using histogram-based thresholding and noise optimization.\n\nArguments\n\ndata::Vector{Float32}  \n\nThe original raw signal to be idealized.\n\nΔt::Float32  \n\nSampling interval in seconds.\n\nmethod::MikaMethod  \n\nParameters for the Mika method, including histogram bin count.\n\nReturns\n\nMikaMethodOutput  \n\nComprehensive structure containing breakpoints, dwell times, idealized signal, noise statistics, and optimized thresholds.\n\nDescription\n\nThis method:\n\nComputes a signal histogram and probability histogram.\nAnalyzes histogram peaks to set up threshold bands.\nEstimates initial breakpoints and dwell times via the threshold region.\nConstructs the idealized signal alternating between two peak levels.\nAssesses noise and fits a normal distribution for MSE optimization.\nIteratively adjusts (optimizes) the threshold to minimize noise MSE.\nReturns all outcomes in a MikaMethodOutput struct for further analysis or plotting.\n\nExample\n\nparams = MikaMethod(ϵ=0.05, number_of_histogram_bins=80)\nresult = mika_method(data, Δt, params)\nprintln(\"Breakpoints: \", breakpoints(result))\nprintln(\"Noise MSE: \", noise_mse(result))\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.noise_test-Tuple{Noise}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.noise_test","text":"noise_test(noise::Noise) :: Float32\n\nEvaluate the normality of noise samples by batching the data and averaging Shapiro-Wilk test p-values.\n\nThis function splits the noise sequence into fixed-size batches, runs a ShapiroWilkTest on each batch, and returns the mean p-value as a summary normality score.\n\nArguments\n\nnoise::Noise: A noise container with fields:\nξ::Vector{Float32}: The raw noise samples.\nμ::Float32: Mean of the noise (metadata; not used in this function).\nσ::Float32: Standard deviation of the noise (metadata; not used here).\n\nReturns\n\nFloat32: The average p-value from Shapiro-Wilk tests across all complete batches. Higher values suggest better agreement with normality.\n\nDetails\n\nUses a fixed batch_size = 50.\nOnly complete batches are tested: num_batches = div(length(noise_data(noise)), batch_size). Any remainder samples are ignored.\nFor each batch, computes ShapiroWilkTest(batch) and stores pvalue(test).\nReturns mean(pvals).\n\nNotes\n\nRequires HypothesisTests (for ShapiroWilkTest) and Statistics (for mean).\nIf the total number of samples is less than batch_size, the function returns NaN (since there are no batches/p-values to average). Consider guarding against this in calling code.\nThe function assumes the presence of noise_data(noise), which should return the vector of samples to test (e.g., noise.ξ). If not defined, replace noise_data(noise) with noise.ξ.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.point-Tuple{HistPeakAnalysis, Symbol, Symbol}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.point","text":"point(hist::HistPeakAnalysis, indexfield::Symbol, valuefield::Symbol) -> Point\n\nExtract a point (x, y) from a histogram analysis result using field names.\n\nArguments\n\nhist::HistPeakAnalysis  \n\nA structurecontaining edges and value fields.\n\nindexfield::Symbol  \n\nThe field name indicating the index (e.g., :pmax1_index).\n\nvaluefield::Symbol  \n\nThe field name indicating the value (e.g., :pmax1).\n\nReturns\n\nPoint  \n\nA Point instance where x is taken from hist.edges at the specified index, and y is the field value accessed from hist.\n\nDescription\n\nThis function provides a generic way to extract coordinates from a histogram analysis result,  allowing flexible selection of peak or trough points for plotting or further calculations.\n\nExample\n\nanalysis = analyze_histogram_peaks(prob_hist)\npeak_pt = point(analysis, :pmax1_index, :pmax1)\nprintln(peak_pt.x, \", \", peak_pt.y)\n\n\n\n\n\n","category":"method"},{"location":"#Deep-Channel-Method","page":"IonChannel.jl Documentation","title":"Deep Channel Method","text":"","category":"section"},{"location":"#Main.IonChannel.deep_channel_method-Tuple{Vector{Float32}, Float32, DeepChannelMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.deep_channel_method","text":"deep_channel_method(data::Vector{Float32}, Δt::Float32, c_method::DeepChannelMethod) \n    :: DeepChannelMethodOutput\n\nApply a deep learning–based ion-channel state detection method to time series data.\n\nArguments\n\ndata::Vector{Float32}: The raw time-series signal (e.g., ion-channel recording).\nΔt::Float32: Sampling interval of the signal. Used to convert sample indices into time units.\nc_method::DeepChannelMethod: A trained deep learning model encapsulated in a DeepChannelMethod  object. The underlying model must support .predict.\n\nReturns\n\nA DeepChannelMethodOutput containing:\n\ndwell_times_approx::Vector{Float32}: Approximate dwell times (time spent in each state).\nbreakpoints::Vector{Float32}: Time points where state transitions occur.\nclass_predict_val::Vector{UInt8}: Per-sample predicted state labels, starting at 0.\n\nMethod\n\nThe input data is scaled into [0,1] using UnitRangeTransform.\nData is reshaped into (N,1,1,1) to match the model’s expected input.\nPredictions are computed with c_method.model.predict.\nThe most likely class per sample is extracted with argmax, producing class_predict_val.\nIterates through predictions to detect state transitions:\nAccumulates dwell times per state.\nRecords breakpoints at transitions.\nReturns dwell times, breakpoints, and the full predicted class sequence.\n\nNotes\n\nPredicted states are output as UInt8 values starting from 0.\nBreakpoints and dwell times are expressed in the same units as Δt.\ndata_augmentation is currently inactive but reserved for possible extensions.\n\nExample\n\ntrace = rand(Float32, 10_000) # synthetic time-series\nΔt = 0.1f0 # sampling interval\nmethod = DeepChannelMethod(model) # previously constructed model\n\nresult = deep_channel_method(trace, Δt, method)\n\nprintln(result.dwell_times_approx)\nprintln(result.breakpoints)\nprintln(result.class_predict_val[1:20])\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.method_function-Tuple{DeepChannelMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.method_function","text":"method_function(::DeepChannelMethod) -> Function\n\nReturn the algorithm function associated with a DeepChannelMethod.\n\nThis allows code like calculate_method(data, m, Δt) to work for any IdealizationMethod subtype without changing the executor logic.\n\n\n\n\n\n","category":"method"},{"location":"#Minimum-Description-Length-Method","page":"IonChannel.jl Documentation","title":"Minimum Description Length Method","text":"","category":"section"},{"location":"#Main.IonChannel._mdl-Tuple{Vector{Float32}, Vector{UInt32}}","page":"IonChannel.jl Documentation","title":"Main.IonChannel._mdl","text":"_mdl(segment::Vector{Float32}, BP::Vector{UInt32}) :: Float32\n\nCompute the Minimum Description Length (MDL) criterion for a piecewise-constant segmentation.\n\nGiven a signal segment and a set of candidate breakpoint indices BP, this function evaluates the MDL cost consisting of a model complexity term and a data-fit term (residual sum of squares within segments). Lower values indicate better segmentations.\n\nThe segmentation is induced by the sorted, unique set {1} ∪ BP ∪ {N}, where N = length(segment).\n\nArguments:\n\nsegment::Vector{Float32}: The data segment to be evaluated.\nBP::Vector{UInt32}: Candidate breakpoint indices (1-based, strictly within 1..N).\n\nReturns:\n\nFloat32: The MDL value; lower is better. Returns Inf if the residual sum of squares (RSS) is non-positive.\n\nDetails:\n\nFor each segment between consecutive breakpoints, the mean is estimated and RSS accumulated.\nComplexity term includes p*log(N) with p = number_of_segments - 1, and a local length penalty 0.5*Σ log(Nseg).\nFit term is (N/2)*log(RSS/N).\n\nNotes:\n\nEmpty subsegments are skipped when accumulating RSS and complexity.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel._test_breakpoint-Tuple{Vector{Float32}, Vector{UInt32}}","page":"IonChannel.jl Documentation","title":"Main.IonChannel._test_breakpoint","text":"_test_breakpoint(segment::Vector{Float32}, candidate::Vector{UInt32}) :: Bool\n\nTest whether adding the proposed breakpoints reduces the MDL criterion.\n\nComputes MDL with and without the candidate breakpoints and returns true if the candidate segmentation yields a strictly lower MDL score.\n\nArguments:\n\nsegment::Vector{Float32}: Data segment to test.\ncandidate::Vector{UInt32}: Proposed breakpoint indices.\n\nReturns:\n\nBool: true if MDL(with candidate) < MDL(without), otherwise false.\n\nNotes:\n\nReturns false when candidate is empty.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.detect_breaks_mdl","page":"IonChannel.jl Documentation","title":"Main.IonChannel.detect_breaks_mdl","text":"detect_breaks_mdl(\n    segment::Vector{Float32},\n    method::AbstractString,\n    min_seg::UInt16=UInt16(300)\n) :: Vector{UInt32}\n\nDetect candidate breakpoint(s) using MDL-backed single or double-break search.\n\nDepending on method, the function delegates to a single- or double-break detector and then validates the proposed breakpoints with the MDL test.\n\nArguments:\n\nsegment::Vector{Float32}: Data to search for breakpoints.\nmethod::AbstractString: Either \"full\" (single-break) or \"full_two_break\" (double-break).\nmin_seg::UInt16: Minimum allowed segment length (in samples).\n\nReturns:\n\nVector{UInt32}: Validated breakpoint indices. Empty if none pass the MDL test or method is unknown.\n\n\n\n\n\n","category":"function"},{"location":"#Main.IonChannel.detect_double_breakpoint","page":"IonChannel.jl Documentation","title":"Main.IonChannel.detect_double_breakpoint","text":"detect_double_breakpoint(\n    data::Vector{Float32},\n    min_seg::UInt16=UInt16(300)\n) :: Vector{UInt32}\n\nSearch for two change points that jointly minimize the sum of within-segment squared errors.\n\nUses cumulative sums to evaluate candidate pairs (i, j) efficiently, enforcing a minimum segment length on all three resulting segments.\n\nArguments:\n\ndata::Vector{Float32}: Input signal.\nmin_seg::UInt16: Minimum segment length for each of the three segments.\n\nReturns:\n\nVector{UInt32}: A 2-element vector [i, j] with the best breakpoints, or empty if none.\n\nNotes:\n\nIf length(data) < 3*min_seg, returns an empty vector without searching.\n\n\n\n\n\n","category":"function"},{"location":"#Main.IonChannel.detect_single_breakpoint","page":"IonChannel.jl Documentation","title":"Main.IonChannel.detect_single_breakpoint","text":"detect_single_breakpoint(\n    data::Vector{Float32},\n    min_seg::UInt16=UInt16(300)\n) :: Vector{UInt32}\n\nFind a single change point that minimizes within-segment squared error, subject to a minimum segment length.\n\nPerforms a linear scan, maintaining incremental means and within-segment sums of squares to identify the index that best splits the data into two segments with minimal total squared error.\n\nArguments:\n\ndata::Vector{Float32}: Input sequence.\nmin_seg::UInt16: Minimum length for each side of the breakpoint.\n\nReturns:\n\nVector{UInt32}: A vector with one breakpoint index, or empty if no valid split is found.\n\nNotes:\n\nIf length(data) < 2*min_seg, no split is attempted and the result is empty.\n\n\n\n\n\n","category":"function"},{"location":"#Main.IonChannel.mdl_method-Tuple{Vector{Float32}, Float32, MDLMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.mdl_method","text":"mdl_method(\n    data::Vector{Float32},\n    Δt::Float32,\n    c_method::MDLMethod\n) :: MDLMethodOutput\n\nPerform MDL-based idealization by iteratively detecting and validating breakpoints, filtering spurious changes by step size, and constructing the idealized state sequence.\n\nPipeline:\n\nIterative breakpoint search:\nStarting from the full range, repeatedly detect single or double breakpoints (via detect_breaks_mdl) within the current segment, respecting c_method.min_seg.\nAccept and insert any proposed breakpoints that pass the MDL test.\nSort and consolidate all local breakpoints.\nFilter by jump magnitude:\nUse stepstat_mdl(data, breaks, c_method.threshold) to remove small steps and estimate segment means.\nConvert sample indices to time:\nbreakpoints = final_breaks .* Δt.\nDetermine initial state using a histogram-derived threshold:\nEstimate amplitude threshold via histogram_calculator, calculate_probability_histogram, and analyze_histogram_peaks, and set initial state to 0 if data[1] < threshold, else 1.\nBuild per-sample idealized sequence by alternating states across final_breaks.\nCompute dwell times as [breakpoints[1]; diff(breakpoints)].\n\nArguments:\n\ndata::Vector{Float32}: Input trace to be idealized.\nΔt::Float32: Sampling interval used to convert indices to time.\ncmethod::MDLMethod: Configuration with `minseg,threshold, andnumberofhistogram_bins`.\n\nReturns:\n\nMDLMethodOutput: Contains breakpoints (Float32 times), dwell_times_approx, and idealized_data (UInt8 states).\n\nNotes:\n\nExpects the following helpers in scope: histogram_calculator, calculate_probability_histogram, and analyze_histogram_peaks returning an object with fields edges and pmin_index.\nState alternation assumes a two-state model (0/1) switching at each retained breakpoint.\nIf final_breaks is empty, ensure calling code handles empty dwell times accordingly.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.method_function-Tuple{MDLMethod}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.method_function","text":"method_function(::MDLMethod)\n\nDispatch helper that maps an MDLMethod configuration to its execution function.\n\nReturns a callable with signature (data::Vector{Float32}, Δt::Float32, c_method::MDLMethod) -> MDLMethodOutput, typically used in higher-level code to select the appropriate idealization routine based on method type.\n\nExample:\n\nf = method_function(MDLMethod(300, 0.8f0, 100))\nout = f(data, Δt, c_method) # calls mdl_method\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.stepstat_mdl","page":"IonChannel.jl Documentation","title":"Main.IonChannel.stepstat_mdl","text":"stepstat_mdl(\n    data::Vector{Float32},\n    BP::Vector{UInt32},\n    threshold::Float32=0.8f0\n) :: Tuple{Vector{UInt32}, Vector{Float32}}\n\nEstimate step values per segment and filter breakpoints by jump magnitude.\n\nGiven breakpoints BP, this function:\n\nappends the end index to form closed segments,\nestimates the mean (stepvalue) for each segment,\ncomputes jumps between consecutive segment means,\nfilters breakpoints whose absolute jump exceeds threshold.\n\nArguments:\n\ndata::Vector{Float32}: Input signal.\nBP::Vector{UInt32}: Candidate breakpoints (1-based).\nthreshold::Float32: Minimum absolute difference between consecutive step means to retain a breakpoint.\n\nReturns:\n\n(filtered::Vector{UInt32}, stepvalue::Vector{Float32}):\nfiltered: Breakpoints surviving the jump threshold.\nstepvalue: Estimated mean level for each (original) segment.\n\nNotes:\n\nEnsures each segment has at least one index; if an interval collapses, it uses the breakpoint index.\n\n\n\n\n\n","category":"function"},{"location":"#Accuracy-of-methods","page":"IonChannel.jl Documentation","title":"Accuracy of methods","text":"","category":"section"},{"location":"#Main.IonChannel.accuracy_of_idealization-Tuple{Vector{UInt8}, Vector{UInt8}}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.accuracy_of_idealization","text":"accuracy_of_idealization(\n    actual_idealization::Vector{UInt8},\n    approx_idealization::Vector{UInt8}\n) :: Float32\n\nCompute the accuracy of an approximate idealization compared to the ground-truth (or reference) idealization.\n\nArguments\n\nactual_idealization::Vector{UInt8}: The reference (true) idealized signal,  represented as a binary vector (0 and 1 states).\napprox_idealization::Vector{UInt8}: The test or approximated idealized trace  to be evaluated.\n\nReturns\n\nFloat32: The accuracy, computed as the proportion of matching states between the two sequences, in the range [0.0, 1.0].\n\nMethod\n\nIf the first state of approx_idealization does not match the first state of actual_idealization, then approx_idealization is inverted (0 ↔ 1) to ensure label consistency.\nAccuracy is calculated as:  sum(actual_idealization .== approx_idealization) / length(approx_idealization)  i.e., the fraction of samples where both sequences agree.\n\nNotes\n\n- This function assumes both inputs are of equal length.\n- If a systematic state-label swap occurred (e.g., model outputs `1` for \"closed\"\nbut reference uses `0`), the inversion step ensures a fair comparison.\n- Accuracy is a simple per-sample metric and may not capture temporal\nmisalignments (e.g., small shifts in breakpoints).\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.actual_idealize_data-Tuple{Dict{String, Vector{Float32}}, Dict{String, Int64}, AbstractString, Float32}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.actual_idealize_data","text":"actual_idealize_data(\n    data::Dict{String, Vector{Float32}},\n    what_first_dict::Dict{String, Int64},\n    data_file_name::AbstractString,\n    Δt::Float32\n) :: Vector{UInt8}\n\nReconstruct a binary idealized signal from dwell-time information by alternating between states 0 and 1 with durations matching the provided dwell times.\n\nArguments\n\ndata::Dict{String, Vector{Float32}}: Dictionary containing at least:\n\"dwell times\": a vector of dwell time durations for consecutive states.\n\"x\": the original data trace (used to match output length).\nwhat_first_dict::Dict{String, Int64}: Dictionary specifying the starting  state for each file, mapped by file name.\ndata_file_name::AbstractString: Name of the dataset; used to select  the initial state from what_first_dict.\nΔt::Float32: Sampling interval of the signal; used to convert dwell  durations into sample counts.\n\nReturns\n\nVector{UInt8}: A binary idealized trace of the same length as data[\"x\"],  representing predicted open/closed states (0/1).\n\nMethod\n\nRetrieve the starting state (what_first) from what_first_dict for the current file.\nInitialize idealized_values with that state.\nFor each dwell time in data[\"dwell times\"]:\nConvert dwell duration into a number of samples: how_many = round(Int, dt / Δt).\nAppend that many samples of the current state.\nSwitch to the opposite state (0 → 1 or 1 → 0).\nEnsure at least one sample is generated for very small dwell times.\nAdjust the length of the result:\nIf longer than data[\"x\"], truncate.\nIf shorter, pad with the next state to match the signal length.\nReturn the finalized binary idealized trace.\n\nNotes\n\nThe function enforces that the returned vector always matches the length of the original recorded trace (data[\"x\"]).\nAlternating states assumes a two-state system (0 and 1), which is standard in patch-clamp idealization.\nHandles dwell durations shorter than Δt by ensuring at least one sample.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.calculate_mean_square_error","page":"IonChannel.jl Documentation","title":"Main.IonChannel.calculate_mean_square_error","text":"calculate_mean_square_error(\n    data::Dict{String, Vector{Float32}}, \n    dwell_times_approx::Vector{Float32}, \n    dt_bins::UInt16=100\n) -> Tuple{Float32, Histogram, Histogram}\n\nCalculate the mean squared error (MSE) between histograms of actual and approximate dwell times,  and return both histograms for further analysis.\n\nArguments\n\ndata::Dict{String, Vector{Float32}}  \n\nA dictionary containing at least the key \"dwell times\" mapped to a vector of observed dwell times (Float32).\n\ndwell_times_approx::Vector{Float32}  \n\nA vector of approximate dwell times to compare against the observed data.\n\ndt_bins::UInt16 (optional, default=100)  \n\nNumber of bins to use when computing histograms for error calculation.\n\nReturns\n\nTuple{Float32, Histogram, Histogram} — (mse, hist_data, hist_approx) where:\n\nmse::Float32  \n\nMean squared error between the histogram bin counts of actual and approximate dwell times.   Computed as the average squared difference in bin weights.\n\nhist_data::Histogram  \n\nHistogram of actual dwell times from data[\"dwell times\"].\n\nhist_approx::Histogram  \n\nHistogram of dwell_times_approx.\n\nDescription\n\nCreates histograms for both actual (data[\"dwell times\"]) and approximate dwell times using histogram_calculator.\nFits exponential distributions to each dataset and computes differences in the fitted scale parameters (θ values).\nCalculates the MSE between the histogram weights of the actual and approximate dwell times.\nReturns the MSE along with both histogram objects for plotting or further analysis.\n\nNotes\n\nUses StatsBase for histogram handling and fit_mle from Distributions for maximum likelihood estimation.\nThe intermediate variables breakpoints and accuracy are currently computed but not returned.\nThe returned histograms can be directly plotted with Plots.jl or analyzed further.\n\nExample\n\nusing Distributions, StatsBase\n\ndata = Dict(\"dwell times\" => rand(Exponential(1.0), 1000))\ndwell_times_approx = rand(Exponential(1.1), 1000)\n\nmse, h_data, h_approx = calculate_mean_square_error(data, dwell_times_approx, 50)\n\nprintln(\"Mean squared error: \", mse)\ndisplay(h_data)\ndisplay(h_approx)\n\n\n\n\n\n","category":"function"},{"location":"#Main.IonChannel.dicts_to_dataframes-Tuple{Dict{String, Dict{String, Vector{Float32}}}, Dict{String, Float32}, Dict{String, Float32}}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.dicts_to_dataframes","text":"dicts_to_dataframes(table::Dict{String,Dict{String,Vector{Float32}}},\n                    mean_accuracy_dict::Dict{String,Float32},\n                    mean_error_dict::Dict{String,Float32}) -> Tuple{DataFrame,DataFrame,DataFrame}\n\nReturn (dferrors, dfaccuracies, df_summary) as DataFrames.\n\ndf_errors: columns per voltage with MSE values (missing padded).\ndf_accuracies: columns per voltage with accuracy values (missing padded).\ndfsummary: one row per voltage with meanerror and mean_accuracy.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.idealize_data-Tuple{Vector{Float32}, Vector{Float32}, HistPeakAnalysis, Float32}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.idealize_data","text":"idealize_data(data::Vector{Float32}, dwell_times_approx::Vector{Float32}, hist_analysis::HistPeakAnalysis, Δt::Float32) -> Vector{UInt8}\n\nConstruct an idealized signal from approximate dwell times and histogram peak analysis.\n\nArguments\n\ndata::Vector{Float32}  \n\nThe original raw data signal.\n\ndwell_times_approx::Vector{Float32}  \n\nApproximate dwell times computed by an idealization method, in seconds.\n\nhist_analysis::HistPeakAnalysis  \n\nResult of histogram peak analysis providing peak intensities and midpoint for thresholding.\n\nΔt::Float32  \n\nSampling interval of the data, in seconds.\n\nReturns\n\nVector{UInt8}  \n\nIdealized signal reconstructed by alternating between the two states 0 and 1, segmented according to the provided dwell times and aligned in length with the original data.\n\nDescription\n\nThis function assigns each dwell segment one of two peak intensities depending on which side of the midpoint the starting value lies. It alternates between these intensities for consecutive dwell segments. The output length matches the input data by truncation or padding.\n\nExample\n\nideal_signal = idealize_data(data, dwell_times_approx, hist_analysis, Δt)\nplot(data, label=\"Raw data\")\nplot!(ideal_signal, label=\"Idealized signal\")\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.mean_error","page":"IonChannel.jl Documentation","title":"Main.IonChannel.mean_error","text":"mean_error(method::IdealizationMethod, Δt::Float32, data_size::UInt32, ::Bool=false) -> Tuple{Dict{String, Dict{String, Vector{Float32}}}, Dict{String, Float32}, Dict{String, Float32}}\n\nCompute the average mean squared error (MSE) across multiple datasets, using a specified idealization method to approximate dwell times.\n\nArguments\n\nmethod::IdealizationMethod  \n\nAn instance of a concrete subtype of IdealizationMethod,   such as MeanDeviationMethod, which stores:     - The dwell-time estimation function.     - Method parameters (e.g. δ, λ values).\n\nΔt::Float32  \n\nSampling interval (seconds) of the recordings.\n\ndata_size::UInt32\n\nNumber of data points to include in each dataset for MSE calculation.\n\nverbose::Bool=false\n\nIf true, prints detailed processing information for each dataset.\n\nReturns\n\nTuple{Dict{String, Dict{String, Vector{Float32}}}, Dict{String, Float32}, Dict{String, Float32}}:  \nA dictionary with keys \"errors\" and \"accuracies\", each mapping to another dictionary where:\nKeys are voltage levels (as strings).\nValues are vectors of MSE or accuracy values for each dataset at that voltage.\nA dictionary mapping voltage levels to their mean accuracy across datasets.\nA dictionary mapping voltage levels to their mean MSE across datasets.\n\nDescription\n\nUses read_all_file_paths to find all raw data and dwell time files.\nFor each dataset:\n\nLoads raw data (x) and actual dwell times (y).\nTruncates data to desired length via get_specified_datapoints.\nNormalizes the \"x\" signal using normalize_data.\nEstimates dwell times by calling calculate_method     with the normalized data, method, and Δt.\nComputes the MSE between actual and estimated dwell times   via calculate_mean_square_error, taking only the MSE value   (first element of its tuple return).\n\nAverages the per-dataset MSE values.\n\nNotes\n\nThis function assumes the folder \"data\" exists and has the expected  \n\nsubfolder structure required by read_all_file_paths.\n\nThe helper calculate_method is responsible for interpreting  \n\nthe IdealizationMethod instance and calling its stored method function.\n\nThe \"x\" and \"dwell times\" vectors are assumed to be aligned and compatible.\ncalculate_mean_square_error now returns a tuple; only the first element is used.\n\nExample\n\nm = MeanDeviationMethod(deviation_from_mean_method, 0.05, 0.5)\nΔt = 1e-4\navg_mse = mean_error(m, Δt, UInt32(10000))\nprintln(\"Average MSE across datasets: \", avg_mse)\n\n\n\n\n\n","category":"function"},{"location":"#Visualization","page":"IonChannel.jl Documentation","title":"Visualization","text":"","category":"section"},{"location":"#Main.IonChannel.plot_idealization_representation-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.plot_idealization_representation","text":"plot_idealization_representation(data::Dict{String, Vector{Float32}}, method_output::MethodOutput, T_left::Float32, T_right::Float32, Δt::Float32)\n\nVisualize ion channel data and its idealization using stacked subplots.   Supports MikaMethodOutput and MeanDeviationMethodOutput.\n\nArguments\n\ndata::Dict{String, Vector{Float32}}  \n\nDictionary containing \"x\" (raw signal data) and associated fields as needed.\n\nmethod_output::MethodOutput  \n\nOutput of an idealization algorithm. If it is MikaMethodOutput, uses the built-in idealized data; if MeanDeviationMethodOutput, reconstructs the idealization using dwell times and histogram analysis.\n\nT_left::Float32\n\nStart time (seconds) for the plot interval.\n\nT_right::Float32  \n\nTotal plot duration (seconds).\n\nΔt::Float32  \n\nSampling interval (seconds).\n\nDescription\n\nCreates a two-row subplot:\n\nTop plot: Raw ion channel current signal (data[\"x\"]) in green.\nBottom plot: Idealized signal in blue.\nFor Mika methods: uses method_output.idealized_data.\nFor Mean Deviation methods: reconstructs idealization using dwell times and peak analysis.\n\nAxes are labeled by time and current.   Legend is suppressed for clarity.   Other idealization outputs can be supported by extending the function.\n\nExample\n\n# For Mika idealization\nplot_idealization_representation(data, mika_output, 0.5, 1.0, 1e-4)\n\n# For mean deviation idealization\nplot_idealization_representation(data, mean_deviation_output, 0.5, 1.0, 1e-4)\n\nNote\n\nFor MeanDeviationMethodOutput, histogram calculation and peak analysis are rerun to reconstruct the idealized trace.\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.show_approx_on_plot-Tuple{Dict{String, Vector{Float32}}, MethodOutput, Float32, Float32, Float32}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.show_approx_on_plot","text":"showapproxonplot(data::Dict{String, Vector{Float32}}, methodoutput::MethodOutput, Tleft::Float32, Tright::Float32, Δt::Float32)\n\nPlot raw data and overlay exact (ground truth) and approximated (idealized) breakpoints, with threshold line for Mika methods.\n\nArguments\n\ndata::Dict{String, Vector{Float32}}  \n\nDictionary containing \"x\" (raw data signal) and \"dwell times\" (vector of dwell segment durations).\n\nmethod_output::MethodOutput  \n\nOutput from an idealization algorithm, providing breakpoints and (for Mika) threshold information.\n\nT_left::Float32\n\nStart time (seconds) for the plot interval.\n\nT_right::Float32  \n\nEnd time (seconds) for the plot interval.\n\nΔt::Float32  \n\nSampling interval (seconds).\n\nDescription\n\nPlots the time series \"x\" for the duration [T_left, T_right] as a green line.  \n\nRed vertical lines: Mark true breakpoints, based on cumulative dwell times from T_left to T_right.\nBlue vertical lines: Indicate approximated breakpoints detected by the idealization method, up to from T_left to T_right.\nThreshold band: If the method_output is a MikaMethodOutput, overlays 2 horizontal lines representing thresold x₁ and x₂.\n\nLine opacities scale with the interval length.   Additional features—such as band limits or idealized data overlay—can be enabled by uncommenting code sections.\n\nExample\n\nshow_approx_on_plot(data, result, 0.5, 0.9, 1e-4)\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.show_threshold_on_plot-Tuple{StatsBase.Histogram, HistPeakAnalysis, MikaMethodOutput}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.show_threshold_on_plot","text":"show_threshold_on_plot(data_histogram::Histogram, histogram_analysis::HistPeakAnalysis, method_output::MikaMethodOutput)\n\nPlot the data histogram and visualize threshold-related features and detected peaks.\n\nArguments\n\ndata_histogram::Histogram  \n\nThe histogram of original data, typically created with histogram_calculator.\n\nhistogram_analysis::HistPeakAnalysis  \n\nResults from peak and minimum detection, providing bin indices for annotated visualization.\n\nmethod_output::MikaMethodOutput  \n\nOutput of the Mika method containing the chosen threshold index and other results.\n\nDescription\n\nCreates a bar plot of the data histogram and overlays vertical lines to indicate:\n\nthe primary and secondary peaks,\nthe histogram midpoint,\nthe selected threshold band location,\nand the minimum between peaks.\n\nThis visualization helps evaluate the effectiveness and placement of the threshold and key features used by the idealization algorithm.\n\nExample\n\nshow_threshold_on_plot(data_histogram, analysis, result)\n\n\n\n\n\n","category":"method"},{"location":"#Additional-functions","page":"IonChannel.jl Documentation","title":"Additional functions","text":"","category":"section"},{"location":"#Main.IonChannel.analyze_histogram_peaks-Tuple{StatsBase.Histogram}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.analyze_histogram_peaks","text":"analyze_histogram_peaks(prob_hist::Histogram) -> HistPeakAnalysis\n\nAnalyze a probability histogram to find the indices and values of major peaks and the trough between them.\n\nArguments\n\nprob_hist::Histogram  \n\nA probability histogram (from StatsBase.Histogram), typically with normalized weights.\n\nReturns\n\nHistPeakAnalysis  \n\nA structure bundling bin edges, weights, indices and values for the two main peaks, the midpoint index, and the minimum value (trough) between the peaks.\n\nDescription\n\nThis function examines the provided histogram to determine the location and values of:\n\nThe primary maximum (pmax1)\nThe secondary maximum (pmax2)\nThe midpoint index between the two maxima\nThe minimum value (pmin) found between those peaks (used for thresholding)\n\nAll results are packed into a HistPeakAnalysis struct for downstream use.\n\nExample\n\ndata = randn(1000) hist = fit(Histogram, data, 50) probhist = calculateprobabilityhistogram(hist) analysis = analyzehistogrampeaks(probhist)\n\nprintln(\"First peak: \", analysis.pmax1, \" at index \", analysis.pmax1index) println(\"Second peak: \", analysis.pmax2, \" at index \", analysis.pmax2index) println(\"Minimum between peaks: \", analysis.pmin, \" at index \", analysis.pmin_index) ```\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.calculate_method-Tuple{Vector{Float32}, IdealizationMethod, Float32}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.calculate_method","text":"calculate_method(data::Vector{Float32}, c_method::IdealizationMethod, Δt::Float32)\n\nRun the dwell-time estimation algorithm associated with the given method type.\n\nArguments\n\ndata::Vector{Float32} - The signal to analyse.\nm::IdealizationMethod - Parameters for the chosen method; algorithm resolved by method(m).\nΔt::Float32 - Sampling interval in seconds.\n\nReturns\n\nVector{Float32} - Dwell times detected by the chosen method.\n\nExample\n\nm = MeanDeviationMethod(0.05, 0.5)\ndwell_times = calculate_dwell_times(signal, m, 1e-4)  \n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.calculate_probability_histogram-Tuple{StatsBase.Histogram}","page":"IonChannel.jl Documentation","title":"Main.IonChannel.calculate_probability_histogram","text":"calculateprobabilityhistogram(histogram::Histogram) -> Histogram\n\nConvert the counts in a histogram to probabilities, producing a probability histogram.\n\nArguments\n\nhistogram::Histogram  \n\nA histogram object (from StatsBase) containing bin edges and weighted counts.\n\nReturns\n\nHistogram  \n\nA new histogram object with the same bin edges as the input, but with weights normalized to sum to 1, representing probabilities.\n\nDescription\n\nThis function takes a histogram of counts or weights and converts it to a probability histogram by dividing each bin’s weight by the total sum of all bin weights.\n\nExample\n\ndata = randn(1000)\nhist = fit(Histogram, data, 50)\nprob_hist = calculate_probability_histogram(hist)\n\nprintln(sum(prob_hist.weights)) # Should print 1.0 (or very close due to floating point)\n\n\n\n\n\n","category":"method"},{"location":"#Main.IonChannel.create_idealizations","page":"IonChannel.jl Documentation","title":"Main.IonChannel.create_idealizations","text":"createidealizations(datafolder::String, Δt::Float32) -> Dict{String, Vector{Int8}}\n\nGenerate idealized binary traces from raw experimental data and dwell times.\n\nThis function reads data files and their associated dwell time files from a given folder (using read_all_file_paths), then produces idealized sequences of 0 and 1 values based on the dwell times and initial state information.\n\nArguments\n\ndata_folder::String: Path to the main data directory.  \n\nMust follow the folder structure expected by read_all_file_paths, with subfolders:\n\nsampling/<voltage>/\ndwell_times/<voltage>/\n\nand an additional file at the top level used to determine the starting state for each trace.\n\nΔt::Float32 (optional, default=1e-4): Time step in seconds used to convert dwell times to point counts.\n\nReturns\n\nDict{String, Vector{Int8}}:  \n\nA dictionary where:\n\nKeys are file names (without path) of the raw data files.\nValues are idealized traces (Vector{Int8}), where elements are 0 or 1.\n\nMethod\n\nCalls read_all_file_paths to get:\n\nPath to the \"first state\" file (what_first_path)\nList of raw data file paths\nList of dwell times file paths\n\nReads the initial states for each trace from the \"first state\" file.\nFor each dataset:\n\nReads raw signal (x) and dwell times (y).\nConstructs a binary vector that alternates between 0 and 1 according to the dwell times.\nEnsures the idealized vector length matches the raw data length by trimming or padding as necessary.\n\nStores the idealized vector in the result dictionary under the base file name of the dataset.\n\nExample\n\nidealized = create_idealizations(\"experiment_data\")\nprintln(keys(idealized)) # List of processed file names\nprintln(idealized[\"trace01.dat\"][1:20]) # First 20 idealized points of a trace\n\nNotes\n\nThe time step Δt is fixed at 1e-4 seconds.\nDwell times are converted to integer point counts via round(Int, dt/Δt).\nIf a computed segment length is 0, it is replaced with a segment of length 1.\nIf the total length exceeds the raw signal length, the idealized trace is truncated;  \n\notherwise, zeros or ones are appended to match the length.\n\nSwitching between 0 and 1 starts from the value given in the what_first_path file\n\nfor the specific trace.\n\n\n\n\n\n","category":"function"},{"location":"#Main.IonChannel.histogram_calculator","page":"IonChannel.jl Documentation","title":"Main.IonChannel.histogram_calculator","text":"histogram_calculator(data::Vector{Float32}, bins::UInt16=100) -> Histogram\n\nCompute a histogram of the given data vector with a specified number of bins.\n\nArguments\n\ndata::Vector{Float32}: A vector of floating-point numbers representing the data to histogram.\nbins::UInt16 (optional, default=100): Number of bins to divide the data range into.\n\nReturns\n\nHistogram: A Histogram object (from StatsBase.jl) representing the frequency distribution\n\nof the data across the specified bins.\n\nMethod\n\nDetermine the minimum (min_data) and maximum (max_data) values in the data.\nDivide the interval [min_data, max_data] into bins equal-width bins.\nUse StatsBase.fit(Histogram, data, edges) to compute the histogram counts and bin edges.\nReturn the histogram object.\n\nExample\n\nusing StatsBase\n\ndata = randn(1000) # 1000 samples from a normal distribution\nhist = histogram_calculator(data, UInt16(50))\nprintln(hist.weights) # Counts per bin\nprintln(hist.edges) # Bin edges\n\nNotes\n\nRequires StatsBase.jl for the Histogram type and fit function.\nThe bins are equally spaced between the minimum and maximum data values.\nThe returned Histogram object contains bin edges and counts, suitable for further analysis or plotting.\n\n\n\n\n\n","category":"function"},{"location":"","page":"IonChannel.jl Documentation","title":"IonChannel.jl Documentation","text":"","category":"page"}]
}
